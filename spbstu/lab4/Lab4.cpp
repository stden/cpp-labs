#include "stdafx.h"


/*************************************************************
	Практическое занятие №3. Функции.
	Объявление, определение, вызов.
	Передача параметров. Возвращение значения.
	Указатели на функции
*************************************************************/
#include <iostream>
#include <tchar.h>
#include <assert.h>
#include <cstdio>
#include <cstdarg>
#include <conio.h>
#include "other.h"

#define	  stop __asm nop

int Min(int** ar, int N, int M){
  int min = ar[0][0];
  for(int i=0;i<N;i++)
    for(int j=0;j<M;j++)
	  if(ar[i][j] < min)
		min = ar[i][j];
  return min;
}

const int M = 3;

int Min(int ar[][M], int N){
  int min = ar[0][0];
  for(int i=0;i<N;i++)
    for(int j=0;j<M;j++)
	  if(ar[i][j] < min)
		min = ar[i][j];
  return min;
}

int MyStrCmp( const char* s1, const char* s2 ){
  int p = 0;
  // Пока обе строки продолжаются и равны - двигаемся вперёд
  while((s1[p] == s2[p]) && s1[p]) p++;
  // Если строки кончились одновременно, значит они равны
  if(s1[p] == s2[p]) return 0;
  return (s1[p] > s2[p]) ? +1 : -1;
}

// Явдяется ли год високосным?
int isLeapYear( int Year ){
  // Год является високосным, если он кратен 4 и при этом не кратен 100, либо кратен 400
  return (Year % 4 == 0) && (Year % 100 != 0) || (Year % 400 == 0); 
}

int DayOfYear( int Day, int Month, int Year, int nDayTab[2][12] ){
  int d = Day;
  for(int m = 0; m < Month-1; m++) // Прибаляем длительность всех предыдущих месяцев
	d += nDayTab[isLeapYear(Year)][m];
  return d; 
}

void DayOfMonth( int DayOfYear, int Year, int nDayTab[2][12],int& rDay,int& rMonth){
  // Считаем, что день равен дню в году
  rDay = DayOfYear;
  // Дальше цикл по месяцам, если количество дней больше чем в первом месяце, вычитаем длину первого месяца
  // и переходим к следующему месяцу
  for(rMonth = 1; rDay > nDayTab[isLeapYear(Year)][rMonth-1]; rMonth++)
	rDay -= nDayTab[isLeapYear(Year)][rMonth-1];
}

// Убираем дубли из массива целых чисел
int* RemoveDuplicates( int* A /* Исходный масив */, int size /* Размер массива */, int& newSize /* Уникальных */ ){
  // Считаем количество уникальных чисел (чтобы отвести нужное количество памяти)
  newSize = 0;
  for(int i=0; i<size; i++){
	bool unique = true; // Предположим, что A[i] не встречался нам ранее в массиве A
	for(int j=0; j<i; j++) // Пробегаем все элементы массива A в поиске такого же элемента как A[i]
      if(A[j] == A[i]){ // Если есть такой же элемент
		unique = false; // То значет гипотеза не верна, найден дубль A[i] ранее
		break; // и мы прерываем цикл, потому что дальше смысла искать нет
	  }
    if(unique) newSize++; // Увеличиваем количество уникальных
  }
  // Заводим массив под уникальные элементы в динамической памяти
  int *res = new int[newSize]; 
  int p=0;
  // И ещё раз пробегаем исходных массив переписывая только нужные элементы
  for(int i=0; i<size; i++){
	bool unique = true; // Предположим, что A[i] не встречался нам ранее в массиве A
	for(int j=0; j<i; j++) // Пробегаем все элементы массива A в поиске такого же элемента как A[i]
      if(A[j] == A[i]){ // Если есть такой же элемент
		unique = false; // То значет гипотеза не верна, найден дубль A[i] ранее
		break; // и мы прерываем цикл, потому что дальше смысла искать нет
	  }
    if(unique){
	  res[p] = A[i];
	  p++;
	}
  }
  // Возвращаем результат
  return res;
}

// Сумма первых N чисел
int sum1N(int N){
  assert( N > 0, "N должно быть больше 0" );
  return (N==1) ? 1 : sum1N(N-1)+N;
}

int _tmain()
{
	setlocale(LC_ALL, "Russian");
	
	/////////////////////////////////////////////////////////////////////////////
	// Задание 1. Ссылки.
	//Объявите ссылку на тип double. Посредством ссылки измените значение

	double d = 1.0;
	double* dr = &d;
	*dr = 2.0;
	std::cout << d << "\n";

	//Раскомментируйте две следующих строчки. Что следует сделать, чтобы
	//linker не выдавал ошибки при создании exe-файла
	extern int& ref;
	ref++;
	std::cout << ref << "\n";

	//Раскомментируйте следующую строку. Что следует сделать, чтобы
	//компилятор не выдавал ошибки 
	
	const int& ref1 = 1;// константная ссылка страница 239
	

	//Задан указатель:
	char c='A';
	char* pc = &c;
	//Объявите ссылку на указатель. Посредством ссылки измените
	//а) значение по адресу
	//б) сам адрес

	char*& ref2= pc;  

	*ref2 = 3;
	ref2 = (char *)4;//приведение к типу char *

	//Задание 2. Отличия при передаче параметров а) по значению,
	// б) по ссылке, в) по указателю
	//Объявите и определите три функции , которые увеличивают заданное
	//с помощью параметра значение на 1 ( а) - IncByValue(),
	// б) - IncByPointer(), в) - IncByReference() ). 
	//Проверьте правильность с помощью отладчика.
	//
	//Замечание: объявления функций принято помещать в заголовочный файл
	int val =1;//значение этой переменной должно быть увеличено с помощью
				//каждой из функций на единицу
	std::cout << "val = " << val << "\n";
	assert( val == 1 ); // Убеждаемся, что в переменной val значение 1
    val = IncByValue(val); 
	assert( val == 2 ); // Переменная val увеличилась
	std::cout << "val = " << val << "\n";
	IncByPointer(&val); // Ещё раз увеличилась по ссылке
	assert( val == 3 );
	std::cout << "val = " << val << "\n";
	IncByReference(val); // Ещё раз увеличилась по значению
	assert( val == 4 );
	std::cout << "val = " << val << "\n";
	stop

	//Задание 2а. Передача параметров c помощью указателя и по ссылке. 
	//Перегруженные имена функций.
	//Создайте функцию (функции) Swap(), которая меняет значения
	//переменных nX и nY местами. 
	// а)Функция должна принимать два указателя на int, оперируя с 
	//которыми менять значения переменных в вызывающей программе
	// б)Функция должна принимать две ссылки на int 
	//Проверьте правильность с помощью приведенного ниже фрагмента.

	int	nX = 1;
	int nY = -1;
	Swap(&nX, &nY);	//поменяли местами значения nX и nY с
						//помощью указателей на nX и nY
	std::cout << "nX = " << nX << " " << nY << "\n";
	Swap(nX, nY);	//а теперь обратно с помощью ссылок на nX и nY
	std::cout << "nX = " << nX << " " << nY << "\n";
	stop

	//Задание 3. Указатели на массивы в качестве аргументов.
	//3a.Напишите два варианта функции поиска минимального элемента
	//1. во встроенном двухмерном массиве
	//2. в динамическом двухмерном массиве (обе размерности вычисляются)
	
	//1.Например:
	const int N = 2;
	int ar[N][M] = {{6,7,4},{4,3,9}/*список инициализаторов*/}; //подумайте - как и где должны быть заданы N и M
	int res = Min(ar, N /* N - количество строк. ... может быть, понадобится передать еще какие-нибудь данные*/ ); 
	std::cout << "min(ar) = " << res << "\n";

	int** ar2 = new int*[N];
	for(int i=0;i<N;i++){
	  ar2[i] = new int[M]; // Заводим в динамической памяти очередную строку
	  for(int j=0;j<M;j++)
	    ar2[i][j] = ar[i][j]; // Инициализируем второй массив теми же значениями что и первый
	}
	int res2 = Min(ar2, N, M ); 
	std::cout << "min(ar2) = " << res2 << "\n";

	//3b. Напишите функцию сравнения двух строк - MyStrCmp():
	//Функция должна принимать два указателя на сравниваемые
	//строки (возможно Вы должны указать компилятору, что функция
	//не имеет права модифицировать содержимое строк)
	//Функция должна возвращать отрицательное значение, если
	//первая строка лексиграфически меньше второй, 0 - если
	//они равны и положительное значение, если первая строка
	//больше второй.
	//Вспомните, что признаком конца строки является нулевой байт.
	
	//Создайте две строки для сравнения: 
	const char* s1 = "Hello";
	const char* s2 = "World!";

	//Вызовите функцию сравнения
	assert( MyStrCmp(s1,s2) == -1 ); // Строка "Hello" меньше чем "World!"
	assert( MyStrCmp(s1,s1) == 0 ); // Строки равны
	assert( MyStrCmp(s2,s1) == +1 ); // Строка "World!" больше "Hello" 
	assert( MyStrCmp("12","12") == 0 ); // Строки равны

	int cmp_res = MyStrCmp(s1,s2);

	//Выведите результат сравнения с помощью cout:
	std::cout << "MyStrCmp(\"" << s1 << "\",\"" << s2 << "\") = " << cmp_res << "\n";

	stop

	//Задание 4.Ссылки в качестве параметров. Передача указателя на встроенный
	//массив в качестве параметра функции.
	//Напишите две взаимодополняющие друг друга функции:
	//1.  ... DayOfYear(...)
	//- преобразует день месяца (число,месяц и год задаются в качестве параметров)
	//в порядковый день года(возвращаемое значение)
	//2. ... DayOfMonth(...) - функция преобразует порядковый день года в день месяца
	// (принимает год и порядковый день года в качестве параметров и должна сформировать
	// день месяца и номер месяца и каким-то образом сообщить эти значения вызывающей процедуре)
	
	//Проверьте работоспособность обеих функций с помощью следующего фрагмента:

	//В процессе вычислений Вам придется учитывать "високосный - невисокосный" год.
	//Для этого предлагается в каждую функцию в качестве одного из параметров передавать
	//данные приведенного ниже двухмерного массива nDayTab

	int nDayTab[2][12]={
		{31,28,31,30,31,30,31,31,30,31,30,31}, //невисокосный год
		{31,29,31,30,31,30,31,31,30,31,30,31}	};	//високосный год
	
	//Вызов функции DayOfYear
    assert( DayOfYear(01,01,2010,nDayTab) == 1 ); // 1 день года
    assert( DayOfYear(01,02,2010,nDayTab) == 31+1 ); // Январь + 1 день
    assert( DayOfYear(10,03,2010,nDayTab) == 31+28+10 ); // Январь + Февраль + 10 дней
	// 2000-ый - високосный
    assert( DayOfYear(01,02,2000,nDayTab) == 31+1 ); // Январь + 1 день
    assert( DayOfYear(10,03,2000,nDayTab) == 31+29+10 ); // Январь + Февраль (високосный) + 10 дней

	//Проверка результата обратной функцией DayOfMonth
	for(int Year=2000;Year<=2010;Year++){
	  int leap = isLeapYear(Year);
   	  for(int Month=1;Month<=12;Month++)
		for(int Day=1;Day<=nDayTab[leap][Month-1];Day++){
		  int dayOfYear = DayOfYear(Day,Month,Year,nDayTab);
		  int rDay,rMonth;
		  DayOfMonth(dayOfYear,Year,nDayTab,rDay,rMonth);
		  assert( Day == rDay );
		  assert( Month == rMonth );
		}
	}
	stop

	//Задание 5. Создайте одномерный массив (размерность вычисляется в процессе
	//выполнения программы), заполните его значениями.
	//Напишите функцию, которая «убирает» из массива дубли. Подсказка: при этом размер
	//массива должен уменьшиться!
	//Для проверки напишите функцию, которая выводит значения всех элементов на экран
	int* numAr;
	int sizeAr = 15; // Задаём размер массива
	numAr = new int[sizeAr]; // Создаём массив в динамической памяти
	for(int i=0; i<sizeAr; i++)
	  numAr[i] = rand() % 8;
	std::cout << "source array: ";
	for(int i=0; i<sizeAr; i++)
	  std::cout << " " << numAr[i];
    std::cout << "\n";

	int newSize;
	int* numArRes = RemoveDuplicates(numAr,sizeAr,newSize);
	std::cout << "result array: ";
	for(int i=0; i<newSize; i++)
	  std::cout << " " << numArRes[i];
    std::cout << "\n";
	  
	//Задание 6. Рекурсивные функции. Напишите рекурсивную функцию вычисления
	//суммы первых N натуральных чисел.

	int NN;
	std::cout << "N = ";
	std::cin >> NN;
	//std::cin >> NN;
	for(int i=1;i<NN;i++)
      std::cout << i << "+";
	std::cout << NN << " = " << sum1N(NN) << "\n";

	//Задание 7а. Функции с переменным числом параметров.
	//Напишите функцию (дана заготовка VarArgs, не использующая
	// макросы), которая принимает переменное число аргументов
	// типа int и выводит на печать число принятых параметров и
	// их значения.
	// Признаком конца списка является нулевое значение.
	
	int nN1=5, nN2=11, nN3=4, nN4=7, nN5=-1;
	VarArgs(nN1,0);	
	VarArgs(nN1,nN2,0);	
	VarArgs(nN1,nN2,nN3,nN4,nN5,0);	
	stop


	//Задание 7б. Модифицируйте функцию 5а с помощью макросов
	// va_start, va_arg, va_end
	VarArgs2(nN1,0);	
	VarArgs2(nN1,nN2,0);	
	VarArgs2(nN1,nN2,nN3,nN4,nN5,0);	
	stop

	//Задание 8. Возвращение адреса.
	//Напишите функцию, которая находит минимальное значение в массиве,
	// таким образом, чтобы ее вызов можно было использовать слева от знака 
	// равенства: *MyMin(параметры) = 0;
	const int Size = 10;
	int* arr = new int[Size];

	std::cout << "Заполняем массив случайными числами: ";
	for(int i=0;i<Size;i++){
	  arr[i] = rand()%12 + 1;
	  std::cout << " " << arr[i];
	}
    std::cout << "\n";

	std::cout << "Меняем первый из минимальных элементов на ноль\n";
	*MyMin(arr,Size) = 0;

	std::cout << "Изменённый массив: ";
	for(int i=0;i<Size;i++)
	  std::cout << " " << arr[i];
    std::cout << "\n\n";

    std::cout << "\n\n Нажмите любую клавишу для выхода...";
	getch();

	return 0;
}//main

