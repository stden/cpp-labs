#include "stdafx.h"


/*************************************************************
  Практическое занятие №3. Функции.
  Объявление, определение, вызов.
  Передача параметров. Возвращение значения.
  Указатели на функции
*************************************************************/
#include <iostream>
#include <tchar.h>
#include <assert.h>
#include <cstdio>
#include <cstdarg>
#include <conio.h>
#include "other.h"

#define   stop __asm nop

int Min(int** ar, int N, int M) {
  int min = ar[0][0];

  for(int i = 0; i < N; i++)
    for(int j = 0; j < M; j++)
      if(ar[i][j] < min)
        min = ar[i][j];

  return min;
}

const int M = 3;

int Min(int ar[][M], int N) {
  int min = ar[0][0];

  for(int i = 0; i < N; i++)
    for(int j = 0; j < M; j++)
      if(ar[i][j] < min)
        min = ar[i][j];

  return min;
}

int MyStrCmp( const char* s1, const char* s2 ) {
  int p = 0;

  // Пока обе строки продолжаются и равны - двигаемся вперёд
  while((s1[p] == s2[p]) && s1[p]) p++;

  // Если строки кончились одновременно, значит они равны
  if(s1[p] == s2[p]) return 0;

  return (s1[p] > s2[p]) ? +1 : -1;
}

// Явдяется ли год високосным?
int isLeapYear( int Year ) {
  // Год является високосным, если он кратен 4 и при этом не кратен 100, либо кратен 400
  return (Year % 4 == 0) && (Year % 100 != 0) || (Year % 400 == 0);
}

int DayOfYear( int Day, int Month, int Year, int nDayTab[2][12] ) {
  int d = Day;

  for(int m = 0; m < Month - 1; m++) // Прибаляем длительность всех предыдущих месяцев
    d += nDayTab[isLeapYear(Year)][m];

  return d;
}

void DayOfMonth( int DayOfYear, int Year, int nDayTab[2][12], int& rDay, int& rMonth) {
  // Считаем, что день равен дню в году
  rDay = DayOfYear;

  // Дальше цикл по месяцам, если количество дней больше чем в первом месяце, вычитаем длину первого месяца
  // и переходим к следующему месяцу
  for(rMonth = 1; rDay > nDayTab[isLeapYear(Year)][rMonth - 1]; rMonth++)
    rDay -= nDayTab[isLeapYear(Year)][rMonth - 1];
}

// Убираем дубли из массива целых чисел
int* RemoveDuplicates( int* A /* Исходный масив */, int size /* Размер массива */, int& newSize /* Уникальных */ ) {
  // Считаем количество уникальных чисел (чтобы отвести нужное количество памяти)
  newSize = 0;

  for(int i = 0; i < size; i++) {
    bool unique = true; // Предположим, что A[i] не встречался нам ранее в массиве A

    for(int j = 0; j < i; j++) // Пробегаем все элементы массива A в поиске такого же элемента как A[i]
      if(A[j] == A[i]) { // Если есть такой же элемент
        unique = false; // То значет гипотеза не верна, найден дубль A[i] ранее
        break; // и мы прерываем цикл, потому что дальше смысла искать нет
      }

    if(unique) newSize++; // Увеличиваем количество уникальных
  }

  // Заводим массив под уникальные элементы в динамической памяти
  int* res = new int[newSize];
  int p = 0;

  // И ещё раз пробегаем исходных массив переписывая только нужные элементы
  for(int i = 0; i < size; i++) {
    bool unique = true; // Предположим, что A[i] не встречался нам ранее в массиве A

    for(int j = 0; j < i; j++) // Пробегаем все элементы массива A в поиске такого же элемента как A[i]
      if(A[j] == A[i]) { // Если есть такой же элемент
        unique = false; // То значет гипотеза не верна, найден дубль A[i] ранее
        break; // и мы прерываем цикл, потому что дальше смысла искать нет
      }

    if(unique) {
      res[p] = A[i];
      p++;
    }
  }

  // Возвращаем результат
  return res;
}

// Сумма первых N чисел
int sum1N(int N) {
  assert( N > 0, "N должно быть больше 0" );
  return (N == 1) ? 1 : sum1N(N - 1) + N;
}

int _tmain() {
  setlocale(LC_ALL, "Russian");

  /////////////////////////////////////////////////////////////////////////////
  // Задание 1. Ссылки.
  //Объявите ссылку на тип double. Посредством ссылки измените значение

  double d = 1.0;
  double* dr = &d;
  *dr = 2.0;
  std::cout << d << "\n";

  //Раскомментируйте две следующих строчки. Что следует сделать, чтобы
  //linker не выдавал ошибки при создании exe-файла
  extern int& ref;
  ref++;
  std::cout << ref << "\n";

  //Раскомментируйте следующую строку. Что следует сделать, чтобы
  //компилятор не выдавал ошибки

  const int& ref1 = 1;// константная ссылка страница 239


  //Задан указатель:
  char c = 'A';
  char* pc = &c;
  //Объявите ссылку на указатель. Посредством ссылки измените
  //а) значение по адресу
  //б) сам адрес

  char*& ref2 = pc;

  *ref2 = 3;
  ref2 = (char*)4; //приведение к типу char *

  //Задание 2. Отличия при передаче параметров а) по значению,
  // б) по ссылке, в) по указателю
  //Объявите и определите три функции , которые увеличивают заданное
  //с помощью параметра значение на 1 ( а) - IncByValue(),
  // б) - IncByPointer(), в) - IncByReference() ).
  //Проверьте правильность с помощью отладчика.
  //
  //Замечание: объявления функций принято помещать в заголовочный файл
  int val = 1; //значение этой переменной должно быть увеличено с помощью
  //каждой из функций на единицу
  std::cout << "val = " << val << "\n";
  assert( val == 1 ); // Убеждаемся, что в переменной val значение 1
  val = IncByValue(val);
  assert( val == 2 ); // Переменная val увеличилась
  std::cout << "val = " << val << "\n";
  IncByPointer(&val); // Ещё раз увеличилась по ссылке
  assert( val == 3 );
  std::cout << "val = " << val << "\n";
  IncByReference(val); // Ещё раз увеличилась по значению
  assert( val == 4 );
  std::cout << "val = " << val << "\n";
  stop

  //Задание 2а. Передача параметров c помощью указателя и по ссылке.
  //Перегруженные имена функций.
  //Создайте функцию (функции) Swap(), которая меняет значения
  //переменных nX и nY местами.
  // а)Функция должна принимать два указателя на int, оперируя с
  //которыми менять значения переменных в вызывающей программе
  // б)Функция должна принимать две ссылки на int
  //Проверьте правильность с помощью приведенного ниже фрагмента.

  int nX = 1;
  int nY = -1;
  Swap(&nX, &nY); //поменяли местами значения nX и nY с
  //помощью указателей на nX и nY
  std::cout << "nX = " << nX << " " << nY << "\n";
  Swap(nX, nY); //а теперь обратно с помощью ссылок на nX и nY
  std::cout << "nX = " << nX << " " << nY << "\n";
  stop

  //Задание 3. Указатели на массивы в качестве аргументов.
  //3a.Напишите два варианта функции поиска минимального элемента
  //1. во встроенном двухмерном массиве
  //2. в динамическом двухмерном массиве (обе размерности вычисляются)

  //1.Например:
  const int N = 2;
  int ar[N][M] = {{6, 7, 4}, {4, 3, 9}/*список инициализаторов*/}; //подумайте - как и где должны быть заданы N и M
  int res = Min(ar, N /* N - количество строк. ... может быть, понадобится передать еще какие-нибудь данные*/ );
  std::cout << "min(ar) = " << res << "\n";

  int** ar2 = new int* [N];

  for(int i = 0; i < N; i++) {
    ar2[i] = new int[M]; // Заводим в динамической памяти очередную строку

    for(int j = 0; j < M; j++)
      ar2[i][j] = ar[i][j]; // Инициализируем второй массив теми же значениями что и первый
  }

  int res2 = Min(ar2, N, M );
  std::cout << "min(ar2) = " << res2 << "\n";

  //3b. Напишите функцию сравнения двух строк - MyStrCmp():
  //Функция должна принимать два указателя на сравниваемые
  //строки (возможно Вы должны указать компилятору, что функция
  //не имеет права модифицировать содержимое строк)
  //Функция должна возвращать отрицательное значение, если
  //первая строка лексиграфически меньше второй, 0 - если
  //они равны и положительное значение, если первая строка
  //больше второй.
  //Вспомните, что признаком конца строки является нулевой байт.

  //Создайте две строки для сравнения:
  const char* s1 = "Hello";
  const char* s2 = "World!";

  //Вызовите функцию сравнения
  assert( MyStrCmp(s1, s2) == -1 ); // Строка "Hello" меньше чем "World!"
  assert( MyStrCmp(s1, s1) == 0 ); // Строки равны
  assert( MyStrCmp(s2, s1) == +1 ); // Строка "World!" больше "Hello"
  assert( MyStrCmp("12", "12") == 0 ); // Строки равны

  int cmp_res = MyStrCmp(s1, s2);

  //Выведите результат сравнения с помощью cout:
  std::cout << "MyStrCmp(\"" << s1 << "\",\"" << s2 << "\") = " << cmp_res << "\n";

  stop

  //Задание 4.Ссылки в качестве параметров. Передача указателя на встроенный
  //массив в качестве параметра функции.
  //Напишите две взаимодополняющие друг друга функции:
  //1.  ... DayOfYear(...)
  //- преобразует день месяца (число,месяц и год задаются в качестве параметров)
  //в порядковый день года(возвращаемое значение)
  //2. ... DayOfMonth(...) - функция преобразует порядковый день года в день месяца
  // (принимает год и порядковый день года в качестве параметров и должна сформировать
  // день месяца и номер месяца и каким-то образом сообщить эти значения вызывающей процедуре)

  //Проверьте работоспособность обеих функций с помощью следующего фрагмента:

  //В процессе вычислений Вам придется учитывать "високосный - невисокосный" год.
  //Для этого предлагается в каждую функцию в качестве одного из параметров передавать
  //данные приведенного ниже двухмерного массива nDayTab

  int nDayTab[2][12] = {
    {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, //невисокосный год
    {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
  };  //високосный год

  //Вызов функции DayOfYear
  assert( DayOfYear(01, 01, 2010, nDayTab) == 1 ); // 1 день года
  assert( DayOfYear(01, 02, 2010, nDayTab) == 31 + 1 ); // Январь + 1 день
  assert( DayOfYear(10, 03, 2010, nDayTab) == 31 + 28 + 10 ); // Январь + Февраль + 10 дней
  // 2000-ый - високосный
  assert( DayOfYear(01, 02, 2000, nDayTab) == 31 + 1 ); // Январь + 1 день
  assert( DayOfYear(10, 03, 2000, nDayTab) == 31 + 29 + 10 ); // Январь + Февраль (високосный) + 10 дней

  //Проверка результата обратной функцией DayOfMonth
  for(int Year = 2000; Year <= 2010; Year++) {
    int leap = isLeapYear(Year);

    for(int Month = 1; Month <= 12; Month++)
      for(int Day = 1; Day <= nDayTab[leap][Month - 1]; Day++) {
        int dayOfYear = DayOfYear(Day, Month, Year, nDayTab);
        int rDay, rMonth;
        DayOfMonth(dayOfYear, Year, nDayTab, rDay, rMonth);
        assert( Day == rDay );
        assert( Month == rMonth );
      }
  }

  stop

  //Задание 5. Создайте одномерный массив (размерность вычисляется в процессе
  //выполнения программы), заполните его значениями.
  //Напишите функцию, которая «убирает» из массива дубли. Подсказка: при этом размер
  //массива должен уменьшиться!
  //Для проверки напишите функцию, которая выводит значения всех элементов на экран
  int* numAr;
  int sizeAr = 15; // Задаём размер массива
  numAr = new int[sizeAr]; // Создаём массив в динамической памяти

  for(int i = 0; i < sizeAr; i++)
    numAr[i] = rand() % 8;

  std::cout << "source array: ";

  for(int i = 0; i < sizeAr; i++)
    std::cout << " " << numAr[i];

  std::cout << "\n";

  int newSize;
  int* numArRes = RemoveDuplicates(numAr, sizeAr, newSize);
  std::cout << "result array: ";

  for(int i = 0; i < newSize; i++)
    std::cout << " " << numArRes[i];

  std::cout << "\n";

  //Задание 6. Рекурсивные функции. Напишите рекурсивную функцию вычисления
  //суммы первых N натуральных чисел.

  int NN;
  std::cout << "N = ";
  std::cin >> NN;

  //std::cin >> NN;
  for(int i = 1; i < NN; i++)
    std::cout << i << "+";

  std::cout << NN << " = " << sum1N(NN) << "\n";

  //Задание 7а. Функции с переменным числом параметров.
  //Напишите функцию (дана заготовка VarArgs, не использующая
  // макросы), которая принимает переменное число аргументов
  // типа int и выводит на печать число принятых параметров и
  // их значения.
  // Признаком конца списка является нулевое значение.

  int nN1 = 5, nN2 = 11, nN3 = 4, nN4 = 7, nN5 = -1;
  VarArgs(nN1, 0);
  VarArgs(nN1, nN2, 0);
  VarArgs(nN1, nN2, nN3, nN4, nN5, 0);
  stop


  //Задание 7б. Модифицируйте функцию 5а с помощью макросов
  // va_start, va_arg, va_end
  VarArgs2(nN1, 0);
  VarArgs2(nN1, nN2, 0);
  VarArgs2(nN1, nN2, nN3, nN4, nN5, 0);
  stop

  //Задание 8. Возвращение адреса.
  //Напишите функцию, которая находит минимальное значение в массиве,
  // таким образом, чтобы ее вызов можно было использовать слева от знака
  // равенства: *MyMin(параметры) = 0;
  const int Size = 10;
  int* arr = new int[Size];

  std::cout << "Заполняем массив случайными числами: ";

  for(int i = 0; i < Size; i++) {
    arr[i] = rand() % 12 + 1;
    std::cout << " " << arr[i];
  }

  std::cout << "\n";

  std::cout << "Меняем первый из минимальных элементов на ноль\n";
  *MyMin(arr, Size) = 0;

  std::cout << "Изменённый массив: ";

  for(int i = 0; i < Size; i++)
    std::cout << " " << arr[i];

  std::cout << "\n\n";

  std::cout << "\n\n Нажмите любую клавишу для выхода...";
  getch();

  return 0;
}//main

