/*************************************************************
  Практическое занятие №3. Встроенные массивы.
              Динамическое выделение памяти.
              Простейшие алгоритмы сортировки и поиска.
              Сложные указатели.
              Ссылки.
*************************************************************/


#define   stop __asm nop
#include <cstdlib>
#include <ctime>
#include <stdio.h>
#include <string.h>
#include <conio.h>
#include <iostream>
using namespace std;
int main() {
  goto YYY;
  ///////////////////////////////////////////////////////////////
  //      Встроенные массивы                               //
  ///////////////////////////////////////////////////////////////

  //Задание 1. Объявите трехмерный массив и сформируйте указанные
  //значения элементов следующим образом:
  //а) проинициализируйте массив при объявлении
  //б) объявите неинициализированный массив и присвойте значения элементам
  //  с помощью кода
  //           |--------|
  //           / |3  3  3 |
  //           |---------|3 |
  //         / | 2  2  2 |3 |
  //        |---------|2 |__|
  //        | 1  1  1 |2 | /
  //        | 1  1  1 |__|
  //        | 1  1  1 | /
  //        |_________|
  //Средствами отладчика проверьте правильность Вашего решения.
  const int N = 3, M = 3, K = 3;
  int nAr [N] [M] [K] = {
    {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}},
    {{2, 2, 2}, {2, 2, 2}, {2, 2, 2}},
    {{3, 3, 3}, {3, 3, 3}, {3, 3, 3}}
  };
  stop

  const int A = 3, B = 3, C = 3;
  int nAr2 [A] [B] [C];

  //int x=1;
  for (int i = 0; i < A; i++) {
    for (int j = 0; j < B; j++) {
      for (int k = 0; k < C; k++) {
        nAr2 [i] [j] [k] = i + 1; //x;
      }

    }

    //x++;
    stop
  }



  //}
  //в) найдите сумму элементов массива
  int sum = 0;

  for (int i = 0; i < A; i++) {
    for (int j = 0; j < B; j++) {
      for (int k = 0; k < C; k++) {
        sum += nAr2[i][j][k];//IntelliSense: требуется выражение????? p.211-212, list 6.20
      }
    }
  }

  {
    int sum = 0;
    int* psum = nAr2[0][0];

    for(int i = 0; i < sizeof(nAr2) / sizeof(int); i++); //p.212, list 6.21

    {
      sum += *psum;
      psum++;
    }
    stop
  }


  //г) проинициализируйте массив при объявлении:
  //           |--------|
  //           / |3  0  0 |
  //           |---------|0 |
  //         / | 2  0  0 |0 |
  //        |---------|0 |__|
  //        | 1  0  0 |0 | /
  //        | 0  0  0 |__|
  //        | 0  0  0 | /
  //        |_________|
  const int X = 3, Y = 3, Z = 3;
  int nAr3 [X] [Y] [Z] = {
    {{1}},
    {{2}},
    {{3}},
  };
  stop

  //// int nnAr; ////
  ////size_t n=sizeof(nnAr)/sizeof(int); ////
  ///*n = sizeof(nAr)/sizeof(nAr[0] [0]);
  //n = sizeof(nAr)/sizeof(nAr[0]);
  //n=sizeof(nAr[0] [0]/sizeof(int);*/

  //stop


  //д) Инициализация массивов строковыми литералами:
  //Объявите и проинициализируйте строковыми литералами два массива:
  //двухмерный массив и массив указателей. Поясните разницу в использовании
  //элементов таких массивов.
  char cstringAr [2] [5] = {"dog", "cat"}; //p.216 выделяется больше памяти
  cstringAr [1] [1] = 'h';

  stop
  ;
  char const* cstringAr1 [] = {"log", "smog"}; //p.217 память выделяется под два указателя для
  //cstringAr1 [1] [1] = 'h';
  stop //одномерного массива cstringAr1; каждому эл-ту массива присваивается зн-е, равное адресу начала
  ;//соотв. строкового литерала


  ///////////////////////////////////////////////////////////////
  //      Динамическое выделение памяти                    //
  ///////////////////////////////////////////////////////////////
  //Задание2. Создайте динамический двухмерный массив с размерностями,
  //вычисляемыми в процессе выполнения программы - N*M.
  //Задайте значения элементов помощью генератора случайных чисел.
  //Найдите  сумму элементов.
  //Подсказка 1: для генерации случайных чисел используйте функцию
  //стандартной библиотеки - rand() (<cstdlib>)
  //Подсказка 2: На самом деле те значения, которые создаются генератором случайных
  //чисел являются «псевдослучайными», то есть при двух последовательных запусках
  //приложения Вы получаете две одинаковые последовательности значений.
  //Для того чтобы генерируемые "случайные" значения были разными при каждом
  //запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
  //и time() (<ctime>).
  //Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
  //Функция time() задает эту точку отсчета, считывая текущее время

  srand(time(0));   //srand( time( 0 ) );
  int N1, M1;
  std::cout << "\n enter a number N = ";
  std::cin >> N1;
  std::cout << "\n enter a number M = ";
  std::cin >> M1;
  //int *lp=new int[N1*M1];
  int** p = new int* [N1]; //////////////////////////

  for (int i = 0; i < N1; i++)
    p[i] = new int [M1];

  int summ2 = 0;

  for (int i = 0; i < N1; i++)
    for (int j = 0; j < M1; j++) {

      p[i][j] =  rand() % 20;
      summ2 += p[i][j];
    }

  for (int i = 0; i < N1; i++) {
    std::cout << "\n";

    for (int j = 0; j < M1; j++) {
      std::cout << " ";
      std::cout << p[i][j];
    }
  }



  //Задание2а. В сформированном массиве отсортируйте каждую строку по
  //убыванию значений. Используйте сортировку "выбором"
  for (int i = 0; i < N1; i++) { //кол-во итераций
    int* pCur = p[i];

    for (int j = 0; j < M1 - 1; j++) {
      int* pMax = pCur; //с сам. большим зн-ем
      int* pTmp = pCur + 1; //pTmp перебор оставшихся эл-в

      for(int y = j + 1; y < M1; y++) { //внутр. цикл
        if(*pTmp > *pMax) pMax = pTmp; //если зн-е больше, перенапр-ся на pMax p.209 p.204-205

        pTmp++;//смещение на след. эл-т
      }

      int tmp = *pMax; //pMax, pCur меняются местами
      *pMax = *pCur;
      *pCur = tmp;
      pCur++;
    }

  }

  for (int i = 0; i < N1; i++) {
    std::cout << "\n";

    for (int j = 0; j < M1; j++)
      std::cout << p[i][j];
  }

  //Задание2б. Объявите одномерный массив размерностью N.
  //Сформируйте значение i-ого элемента одномерного массива
  //равным среднему значению элементов i-ой строки
  //двухмерного массива
  //Подсказка - не забудьте освободить память!
  int* fMas = new int [N1];//с.223 выделение памяти

  for (int i = 0; i < N1; i++) {
    int average = 0;

    for (int j = 0; j < M1; j++)
      average = average + p[i][j];

    fMas[i] = average / M1;
    printf("\n %i \n", fMas[i]);
  }

  delete [] fMas;//освобождение памяти

  for (int i = 0; i < N1; i++) {
    delete[] p[i];
    p = 0;
  }

  delete [] p;
  //delete [] lp;


  /////////////////////////////////////////////////////////////////////
  //Задание 3. а) Напишите фрагмент кода, который вводит NN целых чисел с помощью
  //потока ввода в объявленный Вами встроенный одномерный массив, каждый раз
  //упорядочивая полученное значение по возрастанию
  int N3;
  std::cout << "\n enter a number N3 = "; //p.209, 223-224
  std::cin >> N3;
  int* gMas = new int [N3]; //выделение памяти

  for (int i = 0; i < N3; i++) {
    std::cout << "\n enter a number " << i << "= ";
    std::cin >> gMas[i];
    int* pCur3 = gMas;

    for (int jj = 0; jj < i; jj++) {
      int* pMin3 = pCur3;
      int* pTmp3 = pCur3 + 1;
      //for(int y=jj+1; y<=i; y++)

      {
        if(*pTmp3 < *pMin3) pMin3 = pTmp3; //если зн-е меньше, оно перенапр-ся на pMin3

        pTmp3++;
      }

      int tmp3 = *pMin3;
      *pMin3 = *pCur3;
      *pCur3 = tmp3;
      pCur3++;
    }
  }

  for (int i = 0; i < N3; i++)
    printf(" %i", gMas[i]);

  stop

  {
    const int N3 = 6;
    int gMas[N3] = {0};

    for (int i = 0; i < N3; i++) {
      std::cout << "\n enter a number " << i << "= ";
      std::cin >> gMas[i];

      for(int j = i; j > 0; j--) {
        if( gMas[j] < gMas[j - 1]) {
          int tmp3 = gMas[j];
          gMas[j] = gMas[j - 1];
          gMas[j - 1] = tmp3;


        } else
          break;

      }
    }

    for (int i = 0; i < N3; i++)
      printf(" %i", gMas[i]);
  }



  //б) Простой поиск.
  //Модифицируйте предыдущее задание следующим образом:очередное значение
  //вводится в массив только при условии, что там еще такого нет (то есть
  //дубли игнорируются

  const int N4 = 5;
  int arr1[N4];
  bool Duplicate = 0;

  for(int i = 0; i < N4 - 1; i++)
  MM :   {
    std::cout << "\n enter a number " << i << "= ";
    std::cin >> arr1[i];

    for (int t = 0; t < i; t++) {
      if (arr1[i] == arr1[t] ) { //если ли дубли
        std::cout << "Enter another number! It already exists!" << ' ';
        std::cout << std::endl;
        goto MM;
      }
    }

    for(int j = i; j > 0; j--) {
      if (arr1[j] < arr1[j - 1]) {
        int tmp = arr1[j - 1];
        arr1[j - 1] = arr1[j];
        arr1[j] = tmp;
      } else
        break;
    }

    for(int k = 0; k <= i; k++)
      std::cout << arr1[k] << ' ';

    std::cout << std::endl;
  }

  stop


  ///////////////////////////////////////////////////////////////////////////
  //Задание 4.С помощью данной заготовки напишите программу,
  //которая:
  //вводит строки с клавиатуры с помощью cin>>...
  //в объявленный Вами двухмерный встроенный массив 5*80 элементов типа char;
  //признаком конца ввода является символ * (то есть строка - "*") или
  //заполнение массива (больше свободных строк нет);
  //сортировка строк в алфавитном порядке. Пояснение: крайне
  //не рекомендуется для сортировки сложных объектов физически
  //перемещать их в памяти. Намного эффективнее завести массив
  //указателей на соответствующие строки и перемещать только
  //указатели.

  //Подсказка: для лексиграфического сравнения строк пользуйтесь
  //функцией стандартной библиотеки strcmp(...), заголовочный файл <string>.

  //Определите необходимые значения как константы
  //STOP_STRING  -  "*"  //признак "прекратить ввод"
  //M  -  80 //максимальный размер одной строки
  //N  -  10 //максимальное количество строк в массиве

  //Объявите двухмерный массив с именем cBuffer типа char и
  // размерностью N*M

  //Объявите массив (с именем cPointers) указателей на строки
  //размерностью N

  //Цикл ввода строк:
  //а) выведите приглашение для ввода
  //б) пока не введена строка STOP_STRING или не заполнен весь массив

  const char* STOP_STRING = "*";
  const char D = 10, U = 80;
  char cBuffer[D][U];
  char* cPointers[D];
  std::cout << "Enter a sentence" << "\n";
  int I;

  for ( int i = 0; i < D; i++ ) {
    std::cin >> cBuffer[i];

    if(strcmp(cBuffer[i], STOP_STRING) == 0)
      break;

    cPointers[i] = cBuffer[i]; // iтый указатель на iтую строку
    I = i;
  }

  //ввод строки в массив cBuffer:

  //если введена строка - признак окончания, то выйти из цикла

  //Присвойте элементу массива cPointers с индексом nIndex
  //указатель на строку с номером nIndex в массиве cBuffer

  for(int i = 0; i <= I; i++)
    std::cout << "  " << cPointers[i] << std::endl;

  std::cout << "\n \n";

  //Выдать диагностику о том, что прием строк завершен.

  //Теперь сортируем строки:
  //Цикл сортировки строк по методу "всплывающего пузырька" в
  //порядке возрастания. На каждой итерации - промежуточная печать
  //отсортированных строк

  for(int k = I; k > 0; k--) {
    for(int i = 0; i < k; i++) { //цикл по строкам массива
      bool b = false;

      for (int i = 0; i < k; i++) {
        if (strcmp(cPointers[i], cPointers[i + 1]) == 1) {
          char* pp = cPointers[i];
          cPointers[i] = cPointers[i + 1];
          cPointers[i + 1] = pp;
          b = true;
        }
      }

      if(b == false)
        break;

      stop
    }
  }

  stop
  //{
  ////если строка i идет по алфавиту после строки i+1, то их надо поменять местами
  //  if(strcmp(cPointers[i],cPointers[i+1])==1)
  //  {
  //  char* pp = cPointers[i];
  //  cPointers[i] = cPointers[i+1];
  //  cPointers[i+1] = pp;
  //}
  //}
  //}

  //}
  for(int i = 0; i <= I; i++)
    std::cout << "  " << cPointers[i] << std::endl;

  std::cout << "\n \n";



  //Задание 5. Реализуйте задание №4, используя не встроенные,
  //а динамические массивы (массив?). Так как строки могут быть разной длины,
  //эффективным решением было бы отводить под каждую строку ровно столько байтов,
  //сколько требуется для ее хранения.
  //При этом необходимые параметры (количество строк
  // сформируйте с помощью потока ввода
  //int nStringNumber;
  //Цикл ввода строк:

  int nStringNumber, NumI;
  char Tmp [80];
  const char stop_str[] = {"*"};
  std::cout << "\n enter a number of string\n";
  std::cin >> nStringNumber;
  char** Stroka = new char* [nStringNumber];  // выделяется память под массив указателей p.219

  for ( int i = 0; i < nStringNumber;  i ++) {
    std::cout << "\n Enter a sentence or '*'\n";
    std::cin >> Tmp;
    int Size = 0;
    Size = strlen(Tmp) + 1;
    Stroka[i] = new char[Size];
    strcpy( Stroka[i], Tmp);

    if(strcmp(Stroka[i], stop_str) == 0) {
      std::cout << "\nYou Entered 'stop_str' ";
      break;
      //NumI=i+1;
    }

    NumI = i + 1;
  }

  std::cout << "\n \nInput finished \n\n";
  std::cout << '\n';

  for(int i = 0; i < NumI; i++) {
    std::cout << Stroka[i];
    std::cout << '\n';
  }

  for (int i = 0; i < NumI; i++) {
    for (int j = 0 ; j < NumI - 1; j++) {
      if ( (strcmp(Stroka[j] , Stroka[j + 1])) > 0 ) {
        char* temp = Stroka[j];
        Stroka[j] = Stroka[j + 1];
        Stroka[j + 1] = temp;
      }
    }
  }

  std::cout << '\n';

  for(int i = 0; i < NumI; i++) {
    std::cout << Stroka[i];
    std::cout << '\n';
  }

  //освобождение памяти
  for ( int i = 0; i < nStringNumber;  i ++) {

  }

  delete [] Stroka;
  //delete[] Stroka;//Освобождение занятой памяти
  Stroka = 0;

  stop


  //Цикл сортировки строк по методу "всплывающего пузырька" в
  //порядке возрастания кода первого символа
  //Освобождение занятой памяти:


  //Задание 6.Связь указателей и массивов. Задайте трехмерный
  //встроенный массив [3][3][3]. С помощью операторов [] и *
  //разными способами получите значение [2][2][2] - элемента.
  //Средствами отладчика проверьте правильность Вашего решения.
YYY: {
    const int W = 3;
    int ar[W][W][W];
    ar[2][2][2] = 2;
    std::cout << ar[2][2][2] << "\n";
    std::cout << *(ar[2][2] + 2) << "\n";
    std::cout << *(*(ar[2] + 2) + 2) << "\n";
  }



  //Задание 7. Объявление и использование указателей на многомерные
  // массивы. Проинициализируйте трехмерный массив
  //double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
  //кода, который меняет местами значения элементов четных
  //и нечетных слоев:
  //  было:          |--------|
  //             / |4  4  4 |
  //           |--------| 4 |
  //           / |3  3  3 | 4 |
  //           |---------|3 |   |
  //         / | 2  2  2 |3 | /
  //        |---------|2 |__|
  //        | 1  1  1 |2 | /
  //        | 1  1  1 |__|
  //        | 1  1  1 | /
  //        |_________|

  //  стало:           |--------|
  //             / |3  3  3 |
  //           |--------| 3 |
  //           / |4  4  4 | 3 |
  //           |---------|4 |   |
  //         / | 1  1  1 |4 | /
  //        |---------|1 |__|
  //        | 2  2  2 |1 | /
  //        | 2  2  2 |__|
  //        | 2  2  2 | /
  //        |_________|

  //for(int i=0; i<...; ...)
  //{

  {
    double dArray[4][3][3];

    for(int i = 0; i < 4; i++) {
      for (int j = 0; j < 3; j++) {
        for (int k = 0; k < 3; k++)
          dArray[i][j][k] = i + 1;
      }
    }

    stop

    for (int i = 0; i < 3; i += 2) {
      double (*q)[3] =  dArray[i];
      double (*q1)[3] =  dArray[i + 1];

      for (int j = 0; j < 3; j++) { //переставляем местами элементы i-того и i+1-ого слоев
        for (int k = 0; k < 3; k++) {
          double tmp = q[j][k];
          q[j][k] = q1[j][k];
          q1[j][k] = tmp;
        }
      }

      //if(i==0){i=1;}
    }

    stop
  }

  //Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
  //... =  dArray[i];
  //... =  dArray[i+1];
  //переставляем местами элементы i-того и i+1-ого слоев





  ///////////////////////////////////////////////////////////////////////////
  //Задание 8а. Объявите двухмерный встроенный массив элементов типа char.
  //Сформируйте значения элементов массива с помощью генератора случайных
  //чисел таким образом, чтобы в массиве были только символы '*' и '_'


  //В каждой строке "сдвиньте звездочки" в начало строки, например:
  //было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
  //стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
  //и распечатайте массив по строкам - "постройте распределение"
  srand(time(0));
  const int N6 = 4, M6 = 8;
  char Ar[N6][M6];

  for (int i = 0; i < N6; i++) {
    for (int j = 0; j < M6; j++) {
      //Ar[i][j] = (rand()&1)?'*':'_';
      int R = rand() % 2;

      if (R == 0)
        Ar[i][j] = '*';
      else
        Ar[i][j] = '_';
    }
  }

  for (int i = 0; i < N6; i++) {
    for (int j = 0; j < M6; j++)
      std::cout << " " << Ar[i][j];

    std::cout << "\n\n";
  }


  // 8б. Модифицируйте предыдущее задание следующим способом:
  //После заполнения массива с помощью генератора случайных чисел
  //"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
  //"распределение"
  for (int j = 0; j < M6; j++) {
    int k = N6 - 1;

    for (int i = N6 - 1; i >= 0; i--) { //strings
      if (Ar[i][j] == '*') {
        Ar[i][j] = '_';
        Ar[k][j] = '*';
        k--;
      }
    }
  }

  for (int i = 0; i < N6; i++) {
    for (int j = 0; j < M6; j++)
      std::cout << " " << Ar[i][j];

    std::cout << "\n";
  }

  return 0;
} способом:
//После заполнения массива с помощью генератора случайных чисел
//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
//"распределение"
for (int j = 0; j < M6; j++) {
  int k = N6 - 1;

  for (int i = N6 - 1; i >= 0; i--) { //strings
    if (Ar[i][j] == '*') {
      Ar[i][j] = '_';
      Ar[k][j] = '*';
      k--;