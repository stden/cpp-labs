/*************************************************************
	Практическое занятие №3. Встроенные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/


#define	  stop __asm nop
#include <cstdlib>
#include <ctime>
#include <stdio.h>
#include <string.h>
#include <conio.h>
#include <iostream>
using namespace std;
int main()
{
	goto YYY;
///////////////////////////////////////////////////////////////
//			Встроенные массивы                               //
///////////////////////////////////////////////////////////////

	//Задание 1. Объявите трехмерный массив и сформируйте указанные
	//значения элементов следующим образом:
	//а) проинициализируйте массив при объявлении
	//б) объявите неинициализированный массив и присвойте значения элементам
	//	с помощью кода
	//					 |--------|		
	//				   / |3  3  3 |		
	//    			 |---------|3 |
    //			   / | 2  2  2 |3 |
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__| 
	//			  | 1  1  1 | /
	//			  |_________|
	//Средствами отладчика проверьте правильность Вашего решения.
	const int N=3, M=3, K=3;
	int nAr [N] [M] [K] = {
		{{1, 1, 1}, {1, 1, 1}, {1, 1, 1}},
		{{2, 2, 2}, {2, 2, 2}, {2, 2, 2}},
		{{3, 3, 3}, {3, 3, 3}, {3, 3, 3}}
	};
	stop

	const int A=3, B=3, C=3;
	int nAr2 [A] [B] [C];
	//int x=1;
	for (int i=0; i<A; i++)
	{
	for (int j=0; j<B; j++)
	{
		for (int k=0; k<C; k++)
		{nAr2 [i] [j] [k]=i+1;//x;
		}
		
	}
	//x++;
	stop 
	}



	//}
	//в) найдите сумму элементов массива 
	int sum=0;
	for (int i=0; i<A; i++)
	{
		for (int j=0; j<B; j++)
		{
			for (int k=0; k<C; k++)
			{
				sum += nAr2[i][j][k];//IntelliSense: требуется выражение????? p.211-212, list 6.20
			}
		}
	}
	 
	{
		int sum=0;
		int *psum=nAr2[0][0];
		for(int i=0; i<sizeof(nAr2)/sizeof(int); i++);//p.212, list 6.21
		{
			sum+=*psum;
			psum++;
		}
		stop
	}

	
	//г) проинициализируйте массив при объявлении:
	//					 |--------|		
	//				   / |3  0  0 |		
	//    			 |---------|0 |
    //			   / | 2  0  0 |0 |
	//			  |---------|0 |__|
	//			  | 1  0  0 |0 | /
	//			  | 0  0  0 |__| 
	//			  | 0  0  0 | /
	//			  |_________|
 const int X=3, Y=3, Z=3;
 int nAr3 [X] [Y] [Z]={
	 {{1}},
	 {{2}},
	 {{3}},
 };
 stop
	
	//// int nnAr; ////
	////size_t n=sizeof(nnAr)/sizeof(int); ////
	///*n = sizeof(nAr)/sizeof(nAr[0] [0]);
	//n = sizeof(nAr)/sizeof(nAr[0]);
	//n=sizeof(nAr[0] [0]/sizeof(int);*/

	//stop


	//д) Инициализация массивов строковыми литералами:
	//Объявите и проинициализируйте строковыми литералами два массива:
	//двухмерный массив и массив указателей. Поясните разницу в использовании
	//элементов таких массивов.
	char cstringAr [2] [5] ={"dog", "cat"}; //p.216 выделяется больше памяти
	cstringAr [1] [1] = 'h';
	
stop
	;
char const * cstringAr1 [] ={"log", "smog"}; //p.217 память выделяется под два указателя для  
//cstringAr1 [1] [1] = 'h';
stop //одномерного массива cstringAr1; каждому эл-ту массива присваивается зн-е, равное адресу начала 
	;//соотв. строкового литерала


///////////////////////////////////////////////////////////////
//			Динамическое выделение памяти                    //
///////////////////////////////////////////////////////////////
	//Задание2. Создайте динамический двухмерный массив с размерностями,
	//вычисляемыми в процессе выполнения программы - N*M.
	//Задайте значения элементов помощью генератора случайных чисел.
	//Найдите  сумму элементов.
	//Подсказка 1: для генерации случайных чисел используйте функцию
	//стандартной библиотеки - rand() (<cstdlib>)
	//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
	//чисел являются «псевдослучайными», то есть при двух последовательных запусках
	//приложения Вы получаете две одинаковые последовательности значений.
	//Для того чтобы генерируемые "случайные" значения были разными при каждом 
	//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
	//и time() (<ctime>).
	//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
	//Функция time() задает эту точку отсчета, считывая текущее время
	
srand(time(0)); 	//srand( time( 0 ) );
	int N1,M1;	
	std::cout << "\n enter a number N = "; 
	std::cin >> N1;
	std::cout << "\n enter a number M = "; 
	std::cin >> M1;
    //int *lp=new int[N1*M1];
	int** p = new int*[N1];//////////////////////////
	for (int i=0; i< N1; i++)
	{
		p[i] = new int [M1];
	}
	int summ2=0;
	for (int i=0; i<N1; i++)
		for (int j=0; j<M1; j++)
		{
			
		   p[i][j] =  rand()%20;
		  summ2+= p[i][j];		
		}
	for (int i=0; i<N1; i++)
	{
	std::cout <<"\n";
	for (int j=0; j<M1; j++)
	{std::cout <<" ";
		std::cout <<p[i][j];}}



	//Задание2а. В сформированном массиве отсортируйте каждую строку по
	//убыванию значений. Используйте сортировку "выбором"
	for (int i=0; i<N1; i++)//кол-во итераций
{ int* pCur= p[i];
		for (int j=0; j<M1-1; j++)
		{int* pMax=pCur;//с сам. большим зн-ем
		int* pTmp= pCur+1;//pTmp перебор оставшихся эл-в
				for(int y=j+1; y<M1; y++)//внутр. цикл
		{
			if(*pTmp>*pMax) pMax=pTmp;//если зн-е больше, перенапр-ся на pMax p.209 p.204-205
			pTmp++;//смещение на след. эл-т
		}
			
	int tmp= *pMax;//pMax, pCur меняются местами
	*pMax = *pCur;
	*pCur = tmp;
	pCur++;}

}
    
	for (int i=0; i<N1; i++)
	{
	std::cout <<"\n";
	for (int j=0; j<M1; j++)
	std::cout <<p[i][j];
	}

	//Задание2б. Объявите одномерный массив размерностью N.
	//Сформируйте значение i-ого элемента одномерного массива  
	//равным среднему значению элементов i-ой строки
	//двухмерного массива
	//Подсказка - не забудьте освободить память!
	int* fMas = new int [N1];//с.223 выделение памяти 
  
   for (int i=0; i< N1; i++)
   {   int average=0;
    for (int j=0; j< M1; j++)
	   average=average+p[i][j];
          fMas[i]=average/M1;
		  printf("\n %i \n", fMas[i]);
   }
  
delete [] fMas;//освобождение памяти

for (int i=0; i< N1; i++)
{
	delete[] p[i];
	p = 0;
}
delete [] p;
//delete [] lp;

	
	/////////////////////////////////////////////////////////////////////
	//Задание 3. а) Напишите фрагмент кода, который вводит NN целых чисел с помощью
	//потока ввода в объявленный Вами встроенный одномерный массив, каждый раз
	//упорядочивая полученное значение по возрастанию
	int N3;
	std::cout << "\n enter a number N3 = "; //p.209, 223-224
	std::cin >> N3;
int*gMas = new int [N3];//выделение памяти
   for (int i=0; i<N3; i++)
   {
	std::cout << "\n enter a number "<<i<<"= "; 	
	std::cin >> gMas[i];
	int* pCur3= gMas;
		for (int jj=0; jj<i; jj++)
		{int* pMin3=pCur3;
			int* pTmp3= pCur3+1;
				//for(int y=jj+1; y<=i; y++)
					
		{
			if(*pTmp3<*pMin3) pMin3=pTmp3;//если зн-е меньше, оно перенапр-ся на pMin3
			pTmp3++;
		}
		
		int tmp3= *pMin3;
		*pMin3 = *pCur3;
		*pCur3 = tmp3;
		pCur3++;
		} 
   }
		for (int i=0; i<N3; i++)
	{
	   printf(" %i", gMas[i]);
	}
stop

{
	const int N3 = 6;
	int gMas[N3] = {0};
	  for (int i=0; i<N3; i++)
   {
	std::cout << "\n enter a number "<<i<<"= "; 	
	std::cin >> gMas[i];
	for(int j=i;j>0; j--)
	{
		if( gMas[j]< gMas[j-1])
		{
			int tmp3= gMas[j];
			gMas[j] = gMas[j-1];
			gMas[j-1] = tmp3;


		}else
		{
			break;
		}

	}
   }
		for (int i=0; i<N3; i++)
	{
	   printf(" %i", gMas[i]);
	}
}



	//б) Простой поиск.
	//Модифицируйте предыдущее задание следующим образом:очередное значение
	//вводится в массив только при условии, что там еще такого нет (то есть 
	//дубли игнорируются

	const int N4 = 5;
	   int arr1[N4];
	   bool Duplicate=0;
	   for(int i=0; i<N4-1; i++)  
		MM:   { 
		std::cout << "\n enter a number "<<i<<"= ";
 		std::cin>>arr1[i];

		for (int t=0;t<i;t++)
		   {
			   if (arr1[i]==arr1[t] )//если ли дубли 
			   {
				   std::cout<<"Enter another number! It already exists!"<<' ';
				   std::cout<<std::endl;                       
				   goto MM;
			   }
		   }
		    for(int j=i; j>0; j--)
				   {
					   if (arr1[j]<arr1[j-1])
					   {
						   int tmp = arr1[j-1];
						   arr1[j-1] = arr1[j];
						   arr1[j] = tmp;
					   }
					   else 
					   {
						   break;
					   }			   	  
				   }	
		    for(int k=0; k<=i; k++)
		   {
			   std::cout<<arr1[k]<<' ';
		   }
		   std::cout<<std::endl;
	   }
		   stop
	 

	///////////////////////////////////////////////////////////////////////////
	//Задание 4.С помощью данной заготовки напишите программу,
	//которая:
	//вводит строки с клавиатуры с помощью cin>>...
	//в объявленный Вами двухмерный встроенный массив 5*80 элементов типа char;
	//признаком конца ввода является символ * (то есть строка - "*") или
	//заполнение массива (больше свободных строк нет);
	//сортировка строк в алфавитном порядке. Пояснение: крайне
	//не рекомендуется для сортировки сложных объектов физически
	//перемещать их в памяти. Намного эффективнее завести массив
	//указателей на соответствующие строки и перемещать только
	//указатели.

    //Подсказка: для лексиграфического сравнения строк пользуйтесь
	//функцией стандартной библиотеки strcmp(...), заголовочный файл <string>.
		
	//Определите необходимые значения как константы
 //STOP_STRING  -  "*"	//признак "прекратить ввод"
 //M  -  80	//максимальный размер одной строки
 //N  -  10	//максимальное количество строк в массиве
	
	//Объявите двухмерный массив с именем cBuffer типа char и
	// размерностью N*M

	//Объявите массив (с именем cPointers) указателей на строки
	//размерностью N

	//Цикл ввода строк:
	//а) выведите приглашение для ввода
	//б) пока не введена строка STOP_STRING или не заполнен весь массив
	
	const char* STOP_STRING = "*";
	const char D=10, U=80;
	char cBuffer[D][U];
	char *cPointers[D];
	std::cout<<"Enter a sentence" << "\n";
		int I;
		for ( int i=0; i<D; i++ )
			{    
			std::cin>>cBuffer[i];
				if(strcmp(cBuffer[i],STOP_STRING)==0)
					break;
				cPointers[i] = cBuffer[i]; // iтый указатель на iтую строку
				I=i;
			}
	
		//ввод строки в массив cBuffer:
								
		//если введена строка - признак окончания, то выйти из цикла

		//Присвойте элементу массива cPointers с индексом nIndex
		//указатель на строку с номером nIndex в массиве cBuffer

		for(int i=0; i<=I; i++)
	{
		std::cout<<"  "<<cPointers[i]<<std::endl;
	}
	std::cout<<"\n \n";
	
	//Выдать диагностику о том, что прием строк завершен.
	
	//Теперь сортируем строки:
	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания. На каждой итерации - промежуточная печать 
	//отсортированных строк
	
	for(int k=I; k>0; k--)
	{
		for(int i=0; i<k; i++)   //цикл по строкам массива
		{
			bool b=false; 
			for (int i=0; i<k; i++)
			{
				if (strcmp(cPointers[i],cPointers[i+1])==1)
				{
					char* pp = cPointers[i];
					cPointers[i] = cPointers[i+1];
					cPointers[i+1] = pp;
					b = true;
				} 
			}
			if(b==false)
				break;
			stop
		}
	}
	stop
					//{
					////если строка i идет по алфавиту после строки i+1, то их надо поменять местами
					//	if(strcmp(cPointers[i],cPointers[i+1])==1)
					//	{
					//	char* pp = cPointers[i];
					//	cPointers[i] = cPointers[i+1];
					//	cPointers[i+1] = pp;
				//}
			//}
		//}

	//}
	for(int i=0; i<=I; i++)
	{
		std::cout<<"  "<<cPointers[i]<<std::endl;
	}
	std::cout<<"\n \n";	



	//Задание 5. Реализуйте задание №4, используя не встроенные,
	//а динамические массивы (массив?). Так как строки могут быть разной длины,
	//эффективным решением было бы отводить под каждую строку ровно столько байтов,
	//сколько требуется для ее хранения.
	//При этом необходимые параметры (количество строк
	// сформируйте с помощью потока ввода
	//int nStringNumber;  
	//Цикл ввода строк:

	int nStringNumber, NumI;
	char Tmp [80];
	const char stop_str[]={"*"};
	std::cout <<"\n enter a number of string\n"; 
	std::cin >> nStringNumber;
	char ** Stroka = new char* [nStringNumber]; // выделяется память под массив указателей p.219
	for ( int i = 0; i<nStringNumber;  i ++)
	{
	std::cout <<"\n Enter a sentence or '*'\n";
	std::cin >> Tmp;
	int Size = 0;
	Size = strlen(Tmp)+1;	
	Stroka[i] = new char[Size];
	strcpy( Stroka[i], Tmp);
		if(strcmp(Stroka[i],stop_str)==0)  
	        {
				std::cout <<"\nYou Entered 'stop_str' ";
	        	break;
				//NumI=i+1;
		    }
		 NumI=i+1;
	}
	std::cout <<"\n \nInput finished \n\n";
	std::cout << '\n';
	for(int i=0; i<NumI; i++)
		{
		std::cout << Stroka[i];
		std::cout << '\n';
		}
	for (int i=0; i <NumI; i++)
		{
		for (int j=0 ; j <NumI-1; j++)
			{
			if ( (strcmp(Stroka[j] , Stroka[j+1])) > 0 )
				{
				char* temp = Stroka[j];
				Stroka[j] = Stroka[j+1];
				Stroka[j+1] = temp;
				}
			}
		}
	std::cout << '\n';
	for(int i=0; i<NumI; i++)
	{
		std::cout << Stroka[i];
		std::cout << '\n';
	}
	//освобождение памяти
	for ( int i = 0; i<nStringNumber;  i ++)
{
	
}
	delete [] Stroka;
	//delete[] Stroka;//Освобождение занятой памяти 
	Stroka=0;

stop
  

	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания кода первого символа
	//Освобождение занятой памяти:

	
	//Задание 6.Связь указателей и массивов. Задайте трехмерный
	//встроенный массив [3][3][3]. С помощью операторов [] и *
	//разными способами получите значение [2][2][2] - элемента.
	//Средствами отладчика проверьте правильность Вашего решения.
YYY:	
	{
	const int W=3;
	int ar[W][W][W];
	ar[2][2][2]=2;
	std::cout<<ar[2][2][2]<<"\n";
    std::cout<<*(ar[2][2]+2)<<"\n";
    std::cout<<*(*(ar[2]+2)+2)<<"\n";
	}
  
	

	//Задание 7. Объявление и использование указателей на многомерные
	// массивы. Проинициализируйте трехмерный массив
	//double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
	//кода, который меняет местами значения элементов четных
	//и нечетных слоев:
	//	было:			     |--------|		
	//  				   / |4  4  4 |		
	//					 |--------|	4 |	
	//				   / |3  3  3 |	4 |	
	//    			 |---------|3 |   |
    //			   / | 2  2  2 |3 | /
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__| 
	//			  | 1  1  1 | /
	//			  |_________|

	//	стало:			     |--------|		
	//  				   / |3  3  3 |		
	//					 |--------|	3 |	
	//				   / |4  4  4 |	3 |	
	//    			 |---------|4 |   |
    //			   / | 1  1  1 |4 | /
	//			  |---------|1 |__|
	//			  | 2  2  2 |1 | /
	//			  | 2  2  2 |__| 
	//			  | 2  2  2 | /
	//			  |_________|

	//for(int i=0; i<...; ...)
	//{

	{
	double dArray[4][3][3];	
	for(int i=0; i<4; i++)
		{
			for (int j=0; j<3; j++)
				{
					for (int k=0; k<3; k++)
						{
							dArray[i][j][k] = i+1;
						}
				}
		}
	stop
		for (int i=0; i<3; i+=2)	
		{
			double (*q)[3] =  dArray[i];
			double (*q1)[3] =  dArray[i+1];
			for (int j=0; j<3; j++)//переставляем местами элементы i-того и i+1-ого слоев
				{
					for (int k=0; k<3; k++)
						{
							double tmp = q[j][k]; q[j][k]=q1[j][k]; q1[j][k]=tmp;
						}
				}
			
			//if(i==0){i=1;}
		}

	stop
	}	
	
	//Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
		//... =  dArray[i];
		//... =  dArray[i+1];
		//переставляем местами элементы i-того и i+1-ого слоев



	

	///////////////////////////////////////////////////////////////////////////
	//Задание 8а. Объявите двухмерный встроенный массив элементов типа char.
	//Сформируйте значения элементов массива с помощью генератора случайных 
	//чисел таким образом, чтобы в массиве были только символы '*' и '_'  
	

	//В каждой строке "сдвиньте звездочки" в начало строки, например:
	//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
	//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
	//и распечатайте массив по строкам - "постройте распределение"
	srand(time(0));
	const int N6=4,M6=8;
	char Ar[N6][M6];

	for (int i=0;i<N6;i++)
	{
		for (int j=0;j<M6;j++)
		{
	//Ar[i][j] = (rand()&1)?'*':'_';
			int R = rand()%2;
			if (R==0) {Ar[i][j]='*';}
			else {Ar[i][j]='_';}
		}
	}
	for (int i=0;i<N6;i++)
	{
		for (int j=0;j<M6;j++)
		{
			std::cout<<" "<<Ar[i][j];
		}
		std::cout<<"\n\n";
	}	
   

	// 8б. Модифицируйте предыдущее задание следующим способом:
	//После заполнения массива с помощью генератора случайных чисел
	//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
	//"распределение"
	for (int j=0;j<M6;j++)
		{
			int k=N6-1;
			for (int i=N6-1;i>=0;i--)//strings
				{
					if (Ar[i][j]=='*')
						{
							Ar[i][j]='_';
							Ar[k][j]='*';
							k--;
						}
				}
		}
	for (int i=0;i<N6;i++)
		{
			for (int j=0;j<M6;j++)
				{
				std::cout<<" "<<Ar[i][j];
				}
			std::cout<<"\n";
	}

	return 0;
} способом:
	//После заполнения массива с помощью генератора случайных чисел
	//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
	//"распределение"
	for (int j=0;j<M6;j++)
		{
			int k=N6-1;
			for (int i=N6-1;i>=0;i--)//strings
				{
					if (Ar[i][j]=='*')
						{
							Ar[i][j]='_';
							Ar[k][j]='*';
							k--;