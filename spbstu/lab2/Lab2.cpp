/*************************************************************
  Практическое занятие №2. Побитовые операторы.
              Директивы препроцессора.
              Указатели.
*************************************************************/

#define _USE_MATH_DEFINES // 
#include <iostream>
#include <tchar.h>
#include <cmath>

#define   stop __asm nop  //с помощью директивы препроцессора задаем
//макроподстановку
int _tmain() {
  goto PX;
  // ********************************************************
  setlocale(LC_ALL, ".1251");// Устанавливаем русскоязычную кодировку
  //Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
  //1.1
  {
    int y;//Задайте значение y, например, с помощью потока ввода
    int vivod, i; //Переменная для вывода в двоичном виде и счетчик
    std::cout << "Введите значение y: ";
    std::cin >> y;
    //С помощью побитовых операторов и операторов сдвига выведите значение "y"
    //на консоль в двоичном виде, например:
    //если y==9, то
    // а) 0 0 0 0 ...   0 0 1 0 0 1 (всего 32 двоичных цифры)

    //for (i=1; i<=32; i++)
    //{
    //  vivod=(y>>(32-i))&1;
    //  std::cout<<" "<<vivod;
    //}

    //или пропустите незначащие нули - б) 1 0 0 1

    bool b = 0;

    for (i = 1; i <= 32; i++) {
      vivod = (y >> (32 - i)) & 1;

      if (vivod == 1) b = 1;

      if (b) std::cout << " " << vivod;
    }

    stop
  }


  //1.2 Дана целая переменная
  {
    int y;//Задайте значение y, например, с помощью потока ввода
    std::cout << "Enter y: ";
    std::cin >> y;
    //"Сдвиньте" все единицы в сформированном значении вправо, например:
    //было:   0100 1111 0000 0000 0110 1111 0000 0010
    //стало:  0000 0000 0000 0000 0000 1111 1111 1111
    //Реализовать задачу посредством одного цикла!
    int vivod, i, f, result; //Переменная для вывода в двоичном виде, счетчик, вспомогательная переменная, результат
    result = 1;

    for (i = 31; i >= 0; i--) {
      f = 0;
      f = (y >> i) & 1;

      if (f == 1) result *= 2;
    }

    result = result - 1; // Переменная сформирована

    // и выводим на консоль как в 1.1.
    for (i = 1; i <= 32; i++) {
      vivod = (result >> (32 - i)) & 1;
      std::cout << " " << vivod;
    }
  }


  //1.3 Какие операции следует применить к заданному ниже операнду sNum для
  //того, чтобы переменная sRes приняла требуемое значение?
  //Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
  //использовать один оператор (и при необходимости маску)
  //Замечание 2: посредством оператора xor (подобрав соответствующую маску)
  //можно получить любое значение => этот оператор предполагается использовать
  //в том случае, когда все остальные уже "не спасают"
  {
  PX:
    short sNum = 0x8008;
    short sRes;

    sRes = ~sNum; //0x7ff7 побитовое отрицание

    sRes = sNum | 0x0ff0; //0x8ff8 побитовое сложение

    sRes = sNum & 0x000f;//0x0008 побитовое умножение

    sRes = sNum ^ 0xff00; //0x7f08 побитовое исключающее или

    sRes = sNum ^ 0x7009;//0xf001 побитовое исключающее или

    sRes = sNum ^ 0x8018;//0x0010 побитовое исключающее или
    stop
  }

  stop
  // ********************************************************
  //Задание 2. Директивы препроцессора

  //2.1. Использование "математических" макросов стандартной библиотеки:
  //в заголовочном файле <cmath> (который в свою очередь включает старый
  //файл math.h) определены часто используемые математические
  //константы, например M_PI. Воспользуйтесь этой константой для
  //вычисления длины окружности.
  //Обратите внимание: определения констант в свою очередь тоже заключены
  //в директивы условной трансляции. Что еще, кроме подключения заголовочного
  //файла, требуется сделать???
  {
    float r, l; //Радиус и длина окружности
    std::cout << "Enter r: ";
    std::cin >> r;
    l = 2 * M_PI * r; // длина окружности 2пи на радиус
    stop;
  }

  //2.2.Макросы с параметрами.
  //2.2.1 Напишите свою макроподстановку LENGHT которая вычисляет длину окружности.
  // протестируйте написанный макрос для следующих ситуаций:
  {
    float r;
#define LENGHT(r) 2*M_PI*(r)//  замена length(r) на значение длины окружности
    float l1 = LENGHT(1 + 2); // должно быть 18.8495... ДА
    float l2 = static_cast<float>(1) / static_cast<float>(LENGHT(2)); // должно быть 0.07957... ДА
    stop
#undef LENGHT
  }




  //2.2.2 определите макрос MAX(A, B)  для вычисления б'ольшего
  //значения из двух.

  //Используйте макрос следующим образом. Следите за изменением
  //значений переменных k, i, j. Объясните результат.
  //Постарайтесь убрать побочные эффекты.
  //Отметьте случаи, когда избежать побочных эффектов невозможно

  int A, B;
#define MAX(A, B) ((A<B) ? B : A)
  int i = 10, j = 12, k;
  k = MAX(i, j);
  k = MAX(j, i) * 2;
  k = MAX(j, i + 3);
  k = MAX(i--, j++);
  stop

  //В последнем из расчетов дважды происходит инкрементация j: вначале - до расчета k при определении
  //параметров макроса,затем - при расчете макроса, принявшего значение k=j++

  //2.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
  //двух объектов типа int в памяти местами. Проверьте для приведенного
  //фрагмента. Подумайте, что будет делать макроподстановка, если
  //переставляемые значения разного типа???


  int x1 = 1, y1 = -1;
  int X, Y;
#define EXCHANGE(X, Y) X=X+Y; Y=X-Y; X=X-Y;

  EXCHANGE(x1, y1);
  stop
  int x2 = 100, y2 = -100;
  EXCHANGE(x2, y2);
  stop


  //2.3. Директивы условной трансляции
  //Выполняя следующий фрагмент, посмотрите, какое
  //значение принимает переменная iNN. Что нужно сделать
  //для того, чтобы результат был равен 0? 1? 2?

  //#define NNN
  //#define MMM
  int iNN;
#if defined NNN && defined MMM
  iNN = 0;
#elif defined MMM
  iNN = 1;
#elif defined NNN
  iNN = 2;

#else
  iNN = -1;
#endif

  stop




  //Задание 2.4. Загляните в Project/Properties -> диалоговая панель
  //- Property Pages/C\C++/Preprocessor/Preprocessor definitions.
  //В опциях командной строки в зависимости от мишени сборки проекта
  //(Debug или Release) может быть определено с помощью ключа /D
  //имя _DEBUG. С помощью директив условной
  //трансляции напишите фрагмент кода, который в зависимости от типа
  //мишени выводит с помощью cout разный текст на консоль. Проверьте
  //при разных мишенях сборки.

  //Пусть
  //для мишени Debug в процессе выполнения данного участка
  //кода на экран выводится информация об
  //имени файла, номере строки с функцией вывода, дате и времени
  //компиляции файла, содержащего данную функцию вывода,
  //а также имя функции, содержащей данную строку.
#if defined _DEBUG
  std::cout << "Версия проекта " << __FILE__ << "\nLine " << __LINE__
            << "\nDate " << __DATE__ << "\nTime " << __TIME__ << "\nCurrent function " << __FUNCTION__;
  stop
  //Для мишени Release должна быть просто выведена строка
  //"Release configuration!"
#else
  std::cout << "Release configuration!";
  stop
#endif
  //Подсказка: для получения нужной информации введите в инструментальном
  //окне 'Index' справочной системы следующую ключевую фразу: Predefined Macros

  //Подсказка: мишень сборки проекта можно
  //поменять следующим образом - Build/Configuration Manager/Configuration


  //Задание 2.5. Управляя определенностью идентификатора _UNICODE и используя
  //возможности заголовочного <tchar.h>, объявите и проинициализируйте переменную,
  //которая может становиться как однобайтовой, так и расширенной без
  //изменения исходного текста.
  //С помощью отладчика проверьте результат.

  //#define _UNICODE
#if defined _UNICODE
  typedef wchar_t TCHAR;
#else
  typedef char TCHAR;
#endif

  TCHAR g = 'Ж';
  stop

  // ********************************************************
  //Задание 3.Заголовочные файлы. Директива #include
  //3.1.Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
  //В каждом заголовочном файле объявите перечисление с одинаковыми именами
  //констант, но сопоставьте именованным константам разные значения, например:
  //1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
  //С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
  //констант из 1.h, а в RELEASE-версии значениями констант из 2.h
#if defined _DEBUG // при DEBUG-версии проекта 
#include "first.h"
  MyEnum;
#elif defined NDEBUG // а если release версия
#include "second.h"
  MyEnum;
#endif //признак конца условного блока
  stop


  // ********************************************************

  //Задание 4. Указатели
  //Объявите объекты разных типов и проинициализируйте их.
  //Объявите указатели соответствующих типов и проинициализируйте их
  //адресами заданных объектов.
  //Выполняя задание, с помощью отладчика посмотрите, какие значения
  //будут присвоены переменным-указателям и на что эти указатели
  //"указывают"

  int s = 50;
  bool b = true;
  float f = 2.678;
  char q = 'L';
  int* ps = &s;
  bool* pb = &b;
  float* pf = &f;
  char* pq = &q;

  //Задание 4а. Объявите указатель на тип char и проинициализируйте
  //его адресом строкового литерала. Присвойте переменной типа char значение
  //любого элемента строки.
  //Проверьте - возможно ли присвоить какое-либо значение по адресу,
  //задаваемому указателем?

  char ss[5] = "vot";
  char* pss = &ss [0]; //Операция не проводится без преобразования типа
  char ch = ss[1];
  *pss = 'b'; //Значение первого символа строкового литерала было изменено через указатель
  stop



  //Задание 5. Арифметика указателей. Операция разыменования указателя.
  //Выполняя задание, следите за изменением значений
  //указателей и значений объектов, на которые они указывают.
  //Интерпретируте наблюдаемые результаты
  {
    int nAr[3] = {1, 3}; //Объявлен массив из 3 целых чисел и проинициализирован значениями 1,3,0
    int* pn = &nAr[0]; //Объявлен указатель на нулевой элемент массива
    (*pn)++;  //Значение первого элемента массива инкрементировано
    pn++; //Указатель переведен на первый элемент массива

    char cAr[] = {'A', 'B', 'C', 'D'}; //Объявлен и проинициализирован массив из 4 символьных литералов
    char* pc = &cAr[0]; //Объявлен указатель на нулевой элемент массива
    (*pc) = (*pc) + 5; //Значение первого элемента массива изменено (A + 5 букв по алфавиту = F)
    pc = pc + 3; // Указатель переведен на третий элемент массива (D)

    double dAr[3] = {1.0, 2.0}; //Объявлен и проинициализирован массив из 3 чисел в форме с плавающей точкой
    double* pd1 = &dAr[0]; //Объявлен указатель на нулевой элемент массива
    double* pd2 = pd1; //Объявлен новый указатель (также указывает на нулевой элемент массива)
    (*pd2) += 2; //Значение нулевого элемента массива увеличено на 2
    pd2 += 2; //  Указатель переведен на третий элемент массива (0, инициализирован неявно) pd2 = 0.00000000000000000

    //Объясните результат выполнения операции
    //вычитания двух указателей
    pd1 = &dAr[0];
    pd2 = &dAr[1];
    int nNumber = pd2 - pd1; //Указатель pd2 указывает на элемент массива,
    //расположенный дальше от начала на 1 элемент массива, чем pd1

    //Сравните указатели pd2 и pd1 и с помощью cout
    //выведите результаты сравнения.
    if (pd2 > pd1)
      std::cout << "pd2 больше чем pd1.";
    else if (pd2 == pd1)
      std::cout << "pd2 равен pd1.";
    else
      std::cout << "pd1 больше чем pd2.";


    stop
  }

  //Задание 6. Явное преобразование указателя. Иногда возникает
  //необходимость одни и те же данные интерпретировать по-разному,
  //например, целое можно представить как совокупность четырех
  //байтов и работать с каждым байтом по отдельности. Для этого
  //нужно иметь возможность "указывать" как на целое, так и на байт.
  //Следовательно, возникает необходимость явного преобразования
  //указателя.
  //Подсказка: для правильной интерпретации этого задания воспользуйтесь
  //возможностями отладчика представлять данные в интересующем
  //Вас виде (в данном случае - в шестнадцатеричном) - для
  //этого используйте правую клавишу мыши,находясь в окне
  //переменных и изменяйте пункт - Hexadecimal display

  unsigned int nObject5 = 0x55667788;
  unsigned int* pnObject5 = &nObject5;

  //Раскомментировав следующую строчку кода, обратите внимание
  //на сообщение компилятора - он не считает преобразование
  //"легальным" (безопасным)
  unsigned char* pucObject5;
  //  pucObject5=static_cast<unsigned char*>(pnObject5);  //(1)  выдается ошибка при компиляции
  pucObject5 = reinterpret_cast<unsigned char*>(pnObject5); //а такое
  //преобразование - целиком на совести программиста.
  //Его можно применять, только четко представляя себе
  //результат преобразования (2)

  //Откомментируйте следующие строчки сс==..., p - изменился? *p=...
  char cc = *(pucObject5++); //cc=0x88, p увеличился на 1 байт, *p=0x77
  cc = (*pucObject5)++;// cc=0x77, p не изменился,  *p=0x78

  cc = ++*(pucObject5); //cc=0x79, p не изменился, *p=0x79
  cc = *(++pucObject5); //cc=0x66, p увеличился на 1 байт, *p=0x66,
  stop


  //Задание 7. Void-указатель.
  //Выполняя задание, посмотрите - какие значения присваиваются
  //void-указателю. Обратите внимание: средствами отладчика Вы
  //не можете посмотреть значения, на которые "указывает"
  //void-указатель
  void* pVoid;  //объявление void-указателя
  int nObject3 = 5;
  char cObject3 = 'A';
  int*  pInt = &nObject3;
  pVoid = &nObject3; //адрес nObject3
  pVoid = &cObject3; //адрес cObject3
  pVoid = pInt; //адрес nObject3

  //Прежде, чем раскомментировать следующую строчку, вспомните:
  //что нужно сделать, чтобы выражение стало корректным
  pInt = static_cast<int*>(pVoid);

  //Что нужно сделать для того, чтобы следующее закомментированное выражение
  //стало корректным?
  {
    const int n = 1;
    const void* pnum1 = &n;//????объявить слева void-указатель
  }



  //7a. При выполнении следующего фрагмента посмотрите, какие неприятности
  //могут Вас ожидать при явном приведении типа void-указателя,
  //который в момент времени (1) указывает на double, к типу
  //указателя на int (2)

  double dObject3 = 33.33;
  pVoid = &dObject3;  //(1)

  int nTmp = *(static_cast<int*>(pVoid) ); //(2) //Из-за хранения целых чисел и чисел с плавающей точкой в разных форматах,
  //значение nTmp будет интерпретироваться компилятором с другим числовым значением (1889785610)
  stop

  //Задание 8. Модификатор const. В каждом из заданий
  //объявите указатель требуемого вида. Посредством каждого
  //указателя попробуйте:
  //получить значение по адресу
  //записать новое значение по адресу
  //модифицировать указатель


  //Задание 8a. Указатель является константой.
  {
    int num = 5;
    int* const sum = &num;
    * sum = 7; // меняем значение памяти
    //sum++; так делать нельзя. нельзя менять значение константного указателя, т.к. изменение константного указателя запрещено
  }


  //Задание 8б. Указываемое значение является константой.
  {
    const int zn2 = 10;
    const int* u2 = &zn2;
    // *u2 = 40; //Изменение константного значения запрещено
    u2++;// меняем значение указателя

  }
  stop
  //Задание 8в. И указатель, и указываемое значение
  //являются константами.

  const int pav = 50;
  const int* const fuga = &pav; //константный указатель на константу
  // *pav = 60; //Изменение константного значения запрещено
  // pav++; //Изменение константного указателя запрещено
  stop


  //Задание 8г. Указатель на переменную, объявленную с
  //ключевым словом const.
  const int nN = 1;

  //Объявите указатель и проинициализируйте его выражением - &nN
  const int* d8 = &nN;
  stop



  //Задание 9.При выполнении задания обратите внимание на то,
  //как наглядно отладчик "раскрывает" конструкции типа
  //"указатель на указатель" и на способы получения конечного
  //объекта по таким "иерархическим" указателям
  int n1 = 1;

  //Объявите указатель pn и проинициализируйте его так, чтобы он
  //"указывал" на n1
  int* pn = &n1;

  //Объявите указатель ppn и проинициализируйте его так, чтобы он
  //"указывал" на pn
  int** ppn = &pn;

  //Объявите указатель pppn и проинициализируйте его так, чтобы он
  //"указывал" на ppn
  int** * pppn = &ppn;

  //С помощью указателей pn, ppn и ppn получите значение объекта n1
  //и присвойте его n2

  int     n2;
  n2 =   *pn;
  n2 =  **ppn;
  n2 = *** pppn;


  stop




  return 0;
}//end main
