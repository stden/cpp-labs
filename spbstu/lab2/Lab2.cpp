/*************************************************************
	Практическое занятие №2. Побитовые операторы.
							Директивы препроцессора.
							Указатели.
*************************************************************/

#define _USE_MATH_DEFINES // 
#include <iostream>
#include <tchar.h>
#include <cmath>

#define	  stop __asm nop	//с помощью директивы препроцессора задаем
							//макроподстановку
int _tmain()
{goto PX;
// ********************************************************
	setlocale(LC_ALL, ".1251");// Устанавливаем русскоязычную кодировку
	//Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
	//1.1
	{
	int y;//Задайте значение y, например, с помощью потока ввода
	int vivod, i; //Переменная для вывода в двоичном виде и счетчик
	std::cout<<"Введите значение y: ";
	std::cin>>y;
	//С помощью побитовых операторов и операторов сдвига выведите значение "y"
	//на консоль в двоичном виде, например:
	//если y==9, то
	// а) 0 0 0 0 ...   0 0 1 0 0 1 (всего 32 двоичных цифры)
	
	//for (i=1; i<=32; i++)
	//{
	//	vivod=(y>>(32-i))&1;
	//	std::cout<<" "<<vivod;
	//}
	
	//или пропустите незначащие нули - б) 1 0 0 1

	bool b=0;
	for (i=1; i<=32; i++)
	{
		vivod=(y>>(32-i))&1;
		if (vivod==1) b=1;
		if (b) std::cout<<" "<<vivod;
	}
	stop
	}
	

	//1.2 Дана целая переменная
	{
		int y;//Задайте значение y, например, с помощью потока ввода
		std::cout<<"Enter y: ";
		std::cin>>y;
		//"Сдвиньте" все единицы в сформированном значении вправо, например:
		//было:   0100 1111 0000 0000 0110 1111 0000 0010
		//стало:  0000 0000 0000 0000 0000 1111 1111 1111
		//Реализовать задачу посредством одного цикла!
		int vivod, i, f, result; //Переменная для вывода в двоичном виде, счетчик, вспомогательная переменная, результат
		result=1;
		for (i=31; i>=0; i--)
			{
				f=0;
				f=(y>>i)&1;
				if (f==1) result*=2;
			}
		result=result-1; // Переменная сформирована
		// и выводим на консоль как в 1.1. 
		for (i=1; i<=32; i++)
			{
			vivod=(result>>(32-i))&1;
			std::cout<<" "<<vivod;
			}
	}


	//1.3 Какие операции следует применить к заданному ниже операнду sNum для
	//того, чтобы переменная sRes приняла требуемое значение?
	//Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
	//использовать один оператор (и при необходимости маску) 
	//Замечание 2: посредством оператора xor (подобрав соответствующую маску)
	//можно получить любое значение => этот оператор предполагается использовать
	//в том случае, когда все остальные уже "не спасают" 
	{PX:
	short sNum = 0x8008;
	short sRes;

	sRes = ~sNum; //0x7ff7 побитовое отрицание
	
	sRes = sNum | 0x0ff0; //0x8ff8 побитовое сложение

	sRes = sNum & 0x000f;//0x0008 побитовое умножение

	sRes = sNum ^ 0xff00; //0x7f08 побитовое исключающее или

	sRes = sNum ^ 0x7009;//0xf001 побитовое исключающее или

	sRes = sNum ^ 0x8018;//0x0010 побитовое исключающее или
	stop
	}

	stop
// ********************************************************
	//Задание 2. Директивы препроцессора

	//2.1. Использование "математических" макросов стандартной библиотеки:
	//в заголовочном файле <cmath> (который в свою очередь включает старый
	//файл math.h) определены часто используемые математические
	//константы, например M_PI. Воспользуйтесь этой константой для
	//вычисления длины окружности.
	//Обратите внимание: определения констант в свою очередь тоже заключены
	//в директивы условной трансляции. Что еще, кроме подключения заголовочного
	//файла, требуется сделать???
	{
	float r,l; //Радиус и длина окружности
	std::cout<<"Enter r: ";
	std::cin>>r;
	l=2*M_PI*r; // длина окружности 2пи на радиус
	stop;
	}
	
	//2.2.Макросы с параметрами.
	//2.2.1 Напишите свою макроподстановку LENGHT которая вычисляет длину окружности.
	// протестируйте написанный макрос для следующих ситуаций:
	{
		float r;
		#define LENGHT(r) 2*M_PI*(r)//  замена length(r) на значение длины окружности
		float l1 = LENGHT(1 + 2); // должно быть 18.8495... ДА
		float l2 = static_cast<float>(1) / static_cast<float>(LENGHT(2)); // должно быть 0.07957... ДА
		stop
		#undef LENGHT
	}




	//2.2.2 определите макрос MAX(A, B)  для вычисления б'ольшего
	//значения из двух.
	
	//Используйте макрос следующим образом. Следите за изменением
	//значений переменных k, i, j. Объясните результат.
	//Постарайтесь убрать побочные эффекты.
	//Отметьте случаи, когда избежать побочных эффектов невозможно

	int A,B;
	#define MAX(A, B) ((A<B) ? B : A)
	int i = 10, j = 12, k;
	k = MAX(i, j);
	k = MAX(j, i) * 2;
	k = MAX(j, i+3);
	k = MAX(i--, j++);
	stop
	
	//В последнем из расчетов дважды происходит инкрементация j: вначале - до расчета k при определении 
	//параметров макроса,затем - при расчете макроса, принявшего значение k=j++

	//2.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
	//двух объектов типа int в памяти местами. Проверьте для приведенного
	//фрагмента. Подумайте, что будет делать макроподстановка, если
	//переставляемые значения разного типа???
	
	
	int x1=1, y1=-1;
	int X,Y;
	#define EXCHANGE(X, Y) X=X+Y; Y=X-Y; X=X-Y;
		
	EXCHANGE(x1,y1);
    stop
	int x2=100, y2=-100;
	EXCHANGE(x2,y2);
	stop
	

	//2.3. Директивы условной трансляции
	//Выполняя следующий фрагмент, посмотрите, какое
	//значение принимает переменная iNN. Что нужно сделать
	//для того, чтобы результат был равен 0? 1? 2?

	//#define NNN
	//#define MMM
	int iNN;
	#if defined NNN && defined MMM
	iNN = 0;
	#elif defined MMM
	iNN = 1;
	#elif defined NNN 
	iNN = 2;

	#else
	iNN = -1;
	#endif
	
	stop

	


	//Задание 2.4. Загляните в Project/Properties -> диалоговая панель
	//- Property Pages/C\C++/Preprocessor/Preprocessor definitions.
	//В опциях командной строки в зависимости от мишени сборки проекта
	//(Debug или Release) может быть определено с помощью ключа /D
	//имя _DEBUG. С помощью директив условной
	//трансляции напишите фрагмент кода, который в зависимости от типа
	//мишени выводит с помощью cout разный текст на консоль. Проверьте
	//при разных мишенях сборки.

	//Пусть
	//для мишени Debug в процессе выполнения данного участка
	//кода на экран выводится информация об
	//имени файла, номере строки с функцией вывода, дате и времени 
	//компиляции файла, содержащего данную функцию вывода,
	//а также имя функции, содержащей данную строку.
	#if defined _DEBUG
	std::cout<<"Версия проекта "<<__FILE__<<"\nLine "<<__LINE__
	<<"\nDate "<<__DATE__<<"\nTime "<<__TIME__<<"\nCurrent function "<<__FUNCTION__;
	stop
	//Для мишени Release должна быть просто выведена строка
	//"Release configuration!"
	#else
	std::cout<<"Release configuration!";
	stop
	#endif
	//Подсказка: для получения нужной информации введите в инструментальном
	//окне 'Index' справочной системы следующую ключевую фразу:	Predefined Macros
	
	//Подсказка: мишень сборки проекта можно
	//поменять следующим образом - Build/Configuration Manager/Configuration


	//Задание 2.5. Управляя определенностью идентификатора _UNICODE и используя
	//возможности заголовочного <tchar.h>, объявите и проинициализируйте переменную,
	//которая может становиться как однобайтовой, так и расширенной без 
	//изменения исходного текста.
	//С помощью отладчика проверьте результат.

	//#define _UNICODE
	#if defined _UNICODE
		typedef wchar_t TCHAR;
	#else
		typedef char TCHAR;
	#endif	

	TCHAR g='Ж';
	stop

// ********************************************************
	//Задание 3.Заголовочные файлы. Директива #include
	//3.1.Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
	//В каждом заголовочном файле объявите перечисление с одинаковыми именами
	//констант, но сопоставьте именованным константам разные значения, например:
	//1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
	//С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
	//констант из 1.h, а в RELEASE-версии значениями констант из 2.h
#if defined _DEBUG // при DEBUG-версии проекта 
	#include "first.h"
	MyEnum;
#elif defined NDEBUG // а если release версия
	#include "second.h"
	MyEnum;
#endif //признак конца условного блока
	stop


// ********************************************************

	//Задание 4. Указатели
	//Объявите объекты разных типов и проинициализируйте их.
	//Объявите указатели соответствующих типов и проинициализируйте их
	//адресами заданных объектов. 
	//Выполняя задание, с помощью отладчика посмотрите, какие значения
	//будут присвоены переменным-указателям и на что эти указатели
	//"указывают"

	int s = 50;
	bool b = true;
	float f = 2.678;
	char q = 'L';
	int* ps = &s;
	bool* pb = &b;
	float* pf = &f;
	char* pq = &q;

	//Задание 4а. Объявите указатель на тип char и проинициализируйте
	//его адресом строкового литерала. Присвойте переменной типа char значение
	//любого элемента строки.
	//Проверьте - возможно ли присвоить какое-либо значение по адресу,
	//задаваемому указателем?

	char ss[5]="vot";
	char* pss = &ss [0]; //Операция не проводится без преобразования типа
	char ch = ss[1];
	*pss = 'b'; //Значение первого символа строкового литерала было изменено через указатель
	stop



	//Задание 5. Арифметика указателей. Операция разыменования указателя.
	//Выполняя задание, следите за изменением значений
	//указателей и значений объектов, на которые они указывают.
	//Интерпретируте наблюдаемые результаты
	{
		int nAr[3] = {1,3}; //Объявлен массив из 3 целых чисел и проинициализирован значениями 1,3,0
		int* pn = &nAr[0]; //Объявлен указатель на нулевой элемент массива
		(*pn)++;	//Значение первого элемента массива инкрементировано
		pn++;	//Указатель переведен на первый элемент массива

		char cAr[]={'A','B','C','D'}; //Объявлен и проинициализирован массив из 4 символьных литералов
		char* pc = &cAr[0]; //Объявлен указатель на нулевой элемент массива
		(*pc)=(*pc)+5;	//Значение первого элемента массива изменено (A + 5 букв по алфавиту = F)
		pc=pc+3; //	Указатель переведен на третий элемент массива (D)
	
		double dAr[3]={1.0,2.0}; //Объявлен и проинициализирован массив из 3 чисел в форме с плавающей точкой
		double* pd1 = &dAr[0]; //Объявлен указатель на нулевой элемент массива
		double* pd2 = pd1; //Объявлен новый указатель (также указывает на нулевой элемент массива)
		(*pd2)+=2; //Значение нулевого элемента массива увеличено на 2
		pd2+=2; //	Указатель переведен на третий элемент массива (0, инициализирован неявно) pd2 = 0.00000000000000000

		//Объясните результат выполнения операции
		//вычитания двух указателей
		pd1 = &dAr[0]; 
		pd2 = &dAr[1];
		int nNumber=pd2 - pd1; //Указатель pd2 указывает на элемент массива, 
		//расположенный дальше от начала на 1 элемент массива, чем pd1

		//Сравните указатели pd2 и pd1 и с помощью cout
		//выведите результаты сравнения.
		if (pd2>pd1) 
		{
			std::cout<<"pd2 больше чем pd1.";
		}
		else if (pd2==pd1)
		{
			std::cout<<"pd2 равен pd1.";
		}
		else 
		{
			std::cout<<"pd1 больше чем pd2.";
		}


		stop
	}

	//Задание 6. Явное преобразование указателя. Иногда возникает
	//необходимость одни и те же данные интерпретировать по-разному,
	//например, целое можно представить как совокупность четырех
	//байтов и работать с каждым байтом по отдельности. Для этого
	//нужно иметь возможность "указывать" как на целое, так и на байт. 
	//Следовательно, возникает необходимость явного преобразования
	//указателя. 
	//Подсказка: для правильной интерпретации этого задания воспользуйтесь
	//возможностями отладчика представлять данные в интересующем
	//Вас виде (в данном случае - в шестнадцатеричном) - для
	//этого используйте правую клавишу мыши,находясь в окне
	//переменных и изменяйте пункт - Hexadecimal display

    unsigned int nObject5=0x55667788;
	unsigned int* pnObject5=&nObject5;

	//Раскомментировав следующую строчку кода, обратите внимание
	//на сообщение компилятора - он не считает преобразование 
	//"легальным" (безопасным)
	unsigned char* pucObject5;
//	pucObject5=static_cast<unsigned char*>(pnObject5);	//(1)  выдается ошибка при компиляции
	pucObject5=reinterpret_cast<unsigned char*>(pnObject5);	//а такое
				//преобразование - целиком на совести программиста.
				//Его можно применять, только четко представляя себе
				//результат преобразования (2)

	//Откомментируйте следующие строчки сс==..., p - изменился? *p=...
	char cc = *(pucObject5++); //cc=0x88, p увеличился на 1 байт, *p=0x77
	cc = (*pucObject5)++;// cc=0x77, p не изменился,  *p=0x78

	cc = ++*(pucObject5); //cc=0x79, p не изменился, *p=0x79 
	cc = *(++pucObject5); //cc=0x66, p увеличился на 1 байт, *p=0x66, 
	stop


	//Задание 7. Void-указатель. 
	//Выполняя задание, посмотрите - какие значения присваиваются
	//void-указателю. Обратите внимание: средствами отладчика Вы
	//не можете посмотреть значения, на которые "указывает"
	//void-указатель
	void*	pVoid;	//объявление void-указателя
	int	nObject3=5;
	char cObject3='A';
	int*	pInt = &nObject3;	
	pVoid=&nObject3; //адрес nObject3
	pVoid=&cObject3; //адрес cObject3
	pVoid=pInt; //адрес nObject3
	
	//Прежде, чем раскомментировать следующую строчку, вспомните:
	//что нужно сделать, чтобы выражение стало корректным 	
	pInt=static_cast<int*>(pVoid);

	//Что нужно сделать для того, чтобы следующее закомментированное выражение
	//стало корректным?
	{
		const int n = 1;
		const void*	pnum1 = &n;//????объявить слева void-указатель
	}



	//7a. При выполнении следующего фрагмента посмотрите, какие неприятности
	//могут Вас ожидать при явном приведении типа void-указателя,
	//который в момент времени (1) указывает на double, к типу 
	//указателя на int (2) 

	double dObject3 = 33.33;
	pVoid = &dObject3;	//(1)

	int nTmp = *(static_cast<int*>(pVoid) ); //(2) //Из-за хранения целых чисел и чисел с плавающей точкой в разных форматах,
	//значение nTmp будет интерпретироваться компилятором с другим числовым значением (1889785610)
	stop

		//Задание 8. Модификатор const. В каждом из заданий
		//объявите указатель требуемого вида. Посредством каждого
		//указателя попробуйте:
		//получить значение по адресу
		//записать новое значение по адресу
		//модифицировать указатель

	
		//Задание 8a. Указатель является константой. 
	{
		int num=5;
		int * const sum=&num;
		*sum = 7;// меняем значение памяти
		//sum++; так делать нельзя. нельзя менять значение константного указателя, т.к. изменение константного указателя запрещено
	}
		
				
		//Задание 8б. Указываемое значение является константой.
	{
		const int zn2= 10;
	const int * u2 = &zn2;
	// *u2 = 40; //Изменение константного значения запрещено
	u2++;// меняем значение указателя
	
	}
	stop
		//Задание 8в. И указатель, и указываемое значение
		//являются константами. 

	const int pav= 50;
	const int * const fuga = &pav;//константный указатель на константу
	// *pav = 60; //Изменение константного значения запрещено
	// pav++; //Изменение константного указателя запрещено
	stop


		//Задание 8г. Указатель на переменную, объявленную с
		//ключевым словом const. 
	const int nN = 1;

	//Объявите указатель и проинициализируйте его выражением - &nN	
	const int * d8 = &nN;
	stop



	//Задание 9.При выполнении задания обратите внимание на то,
	//как наглядно отладчик "раскрывает" конструкции типа
	//"указатель на указатель" и на способы получения конечного
	//объекта по таким "иерархическим" указателям
	int	n1=1;

    //Объявите указатель pn и проинициализируйте его так, чтобы он
	//"указывал" на n1
	int * pn = &n1;

    //Объявите указатель ppn и проинициализируйте его так, чтобы он
	//"указывал" на pn
	int ** ppn = &pn;

    //Объявите указатель pppn и проинициализируйте его так, чтобы он
	//"указывал" на ppn
	int *** pppn = &ppn;
  
	//С помощью указателей pn, ppn и ppn получите значение объекта n1
	//и присвойте его n2

	int     n2;
	n2 =   *pn;
	n2 =  **ppn;
	n2 = ***pppn;

  
	stop




	return 0;
}//end main
