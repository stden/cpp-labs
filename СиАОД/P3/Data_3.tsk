Тема 3. СПИСКИ И ДЕРЕВЬЯ

1. Определения.
     Дерево представляет собой конечное множество T, состоящее из
N элементов - узлов (N >= 1), один из которых называется корнем дерева.
С корнем связано конечное  число  непересекающихся  подмножеств
T1..Tm - поддеревьев (m > 0), каждое из которых является деревом
[2, т. 1, стр 382]. Данное определение является рекурсивным, т. е.
мы определили дерево в терминах самого дерева. Рекурсивность
является естественным свойством подобных структур, структур типа
"дерево".

     Понятие рекурсии [3].
     Композиция X называется рекурсивной, если она может быть оп-
ределена как X => {S,X},  где S - некоторая композиция  элементов
той же природы, что и X.

     Для того,  чтобы рекурсивное определение не порождало беско-
нечных композиций,  X следует строить в соответствии с правилом
X => {S,if B then X}, где B некоторое логическое выражение, зна-
чение которого в какой-то момент становится ложным. В определении
дерева это реализуется за счет того,  что число элементов каждого
"последующего" подмножества меньше, чем "предыдущего".

     Двоичное дерево - это дерево,  каждый узел которого имеет не
более двух потомков.

     Реализация дерева с помощью списка, пример.

{ Пример демонстрирует построение двоичного дерева для последова-
  тельности чисел,  у которого все значения чисел в узлах  любого
  левого поддерева меньше значения числа в его корне, а правого -
  больше или равно.}




                              - 2 -

type Pointer = ^Node;
     Node = record
        Member: integer;
        Left,Right: Pointer
     end;

var Tree: Pointer;
    i: integer;

function ReadN(m: integer): integer;
const D: array[1..8] of integer = (11,4,5,18,9,22,1,25);
begin
   ReadN:= D[m]
end; {ReadN}

procedure Bild;
var p,q: Pointer;
    X: integer;
begin
   i:= 1; X:= ReadN(i);
   New(q); Tree:= q;
   Tree^.Member:= X; Tree^.Left:= nil; Tree^.Right:= nil;

   while i < 8 do begin
      i:= i + 1;
      X:= ReadN(i);
      q:= Tree;
      while (q <> nil) do begin
      p:= q;
         if q^.Member < X then  q:= q^.Right
                          else  q:= q^.Left
      end;{while}
      New(q); q^.Member:= X; q^.Left:= nil; q^.Right:= nil;
      if p^.Member < X then p^.Right:= q
                       else p^.Left:= q;
   end{while}
end;{Bild}


                              - 3 -

     При работе  с  рекурсивно  определенными  структурами данных
часто целесообразно использование рекурсивных действий. Пример.

{ На  примере  процедуры SortTree,  обеспечивающей вывод исходных
  чисел в порядке возрастания,  показано  использование  рекурсии
  для обхода дерева }

procedure SortTree(p: Pointer);
begin
  if p <> nil then begin
     SortTree(p^.Left);
     Write(p^.Member,' ');
     SortTree(p^.Right)
  end{if}
end;{SortTree}

begin
    ClrScr;
    Bild;
    WriteLn;
    SortTree(Tree); ReadLn;
end.


2. Содержание задания.
     Пусть задано  некоторое арифметическое выражение,  в котором
использованы четыре действия целой десятичной арифметики *,/,+ и -
(например: c*(a + b)*(d - f/e)).
     Известны три формы записи таких выражений:
     инфиксная форма    ( c*(a + b)*(d - f/e) ),
     префиксная форма   ( **c+ab*-d/fe ),
     постфиксная форма  ( cab+*dfe/-* ).

     2.1. Разработать программный модуль,  реализующий тип данных
"двоичное дерево" для решения пунктов задания, представленных ни-
же.
     2.2. Реализовать  процедуру,  выполняющую  построение дерева
для конкретного арифметического выражения, заданного в префиксной

                              - 4 -

форме и состоящего из 16-ти символов (буквенных символов и симво-
лов операций).
     2.3. Реализовать процедуру обхода полученного дерева и выво-
да на экран исходного выражения в трех формах записи.
     2.4. Используя тип данных "стек",  реализовать процедуру вы-
числения значения арифметического выражения, записанного на полу-
ченном дереве при конкретных значениях буквенных символов.

3. Требования к реализации.

       3.1. Процедуры задания 2.1 и 2.2 должны быть рекурсивными.

       3.2. При реализации задания 2.4  использовать  результаты,
полученные при разработке заданий предыдущей темы.

4. Требования к отчетной документации.

   Отчетная документация содержит следующие разделы.
      1. Постановка задачи.
      2. Принцип реализации и ее обоснование.
         Приводится идея,  положенная в основу реализации задания
и обоснование реализации с точки  зрения  выполнения  требований,
приведенных выше.
      3. Описание  последовательности  действий  и  промежуточных
значений переменных при работе процедуры задания 2.3.
      4. Описание и тексты программ.

   Литература.

1. Й.  Лэнгсам. Структуры данных для персональных ЭВМ. - М.: Мир,
   1989.
2. Д. Кнут. Искусство программирования для ЭВМ. - М.: Мир, 1976.
3. Н.  Вирт. Алгоритмы + структуры данных = программы. - М.: Мир,
   1985.
