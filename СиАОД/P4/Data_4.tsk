Тема 4. ДЕРЕВО ПОИСКА И ПРИМЕР ЕГО ИСПОЛЬЗОВАНИЯ.

1. Определения.
     Рассмотрим ТАБЛИЦУ со следующей СТРУКТУРОЙ:

         -------это  ИНДЕКС (номер по порядку)
       ┌─|─┬──────┬─────────┬──────┬─────┐
       │ N │ Имя  │ Возраст │ Рост │ Вес ---- это ПОЛЕ
       ├───┼──────┼─────────┼──────┼─────┤

     и пример ее заполнения:

       │ 1 │ Маша │  14     │ 126  │ 32  │
       │ 2 ----------------------------------
       │ 3 │ Саша │   8     │  74  │ 26  │    это ЗАПИСЬ
       │   ----------------------------------
       │ 4 │ Юля  │  11     │ 110  │ 30  │
       │ 5 │ Вася │  10     │ 100  │ 29  │
       │ 6 │ Коля │  16     │ 150  │ 58  ---- это ЗНАЧЕНИЕ ПОЛЯ
       │ 7 │ Даша │   9     │  98  │ 45  │
       │ 8 │ Петя │   5     │  70  │ 25  │

     Допустим, что  мы хотим найти человека по заданному имени и
посмотреть его параметры.  Ничего сложного!  Взяли, посмотрели на
таблицу - и нашли. А если таблица состоит из 10 000 строк? Плохо!
Надо перебирать значения ИМЕН пока не наткнемся на подходящее.
     Хорошо было  бы такую таблицу отсортировать по алфавиту хотя
бы первых букв имен,  что существенно облегчило бы поиск. Очевид-
но, что ИСКАТЬ В ОТСОРТИРОВАННОЙ ТАБЛИЦЕ ПРОЩЕ.
     (Нетрудно предположить,  что  может  понадобиться  сортировка
таблицы и по другому полю.)
     Формализуем понятие СОРТИРОВКА.
     Пусть задана таблица из n записей:
              a1, a2 ... an.
     Пусть задана функция F(x) на множестве X = {ai}.  Назовем
СОРТИРОВКОЙ процесс получения некоторой новой таблицы
             ai1, ai2, ... ain,
     для которой
             F(ai1)<=F(ai2)<=F(ai3).....<=F(ain).
     Как правило, в качестве множества значений функции F выбирают
значения некоторого поля, которое называют КЛЮЧОМ записи:
             F(x) = Значение_поля_X_таблицы_A
     Сортировка - дело хлопотное. Поэтому можно поступить следую-
щим образом. Построить еще одну таблицу:

              ┌──────┬────────┐
              │ Ключ │ Индекс │
              ├──────┼────────┤
              │ Вася │   5    │
              │ Даша │   7    │
              │ Коля │   6    │
              │ Маша │   1    │
              │ Петя │   8    │
              │ Саша │   3    │
              │ Юля  │   4    │

     Т.е. "основную" таблицу не трогаем, поиск имени осуществляем
с помощью "дополнительной", ИНДЕКСНОЙ таблицы и, найдя нужное нам
имя,  получаем значение индекса элемента.  А далее  из "основной"
таблицы по полученному индексу находим искомый элемент  со  всеми
атрибутами. Хорошо ли это? Жизнь показывает, что очень.
     Т.е. - что мы сделали?  Имея некоторую "основную" таблицу, мы
строим "вспомогательную" структуру данных,  облегчающую поиск.
     Обязательно ли в качестве такой "вспомогательной"  структуры
выбирать таблицу?  А что если, учитывая, что для деревьев сущест-
вует масса замечательных алгоритмов работы  с  ними,  попробовать
для этой цели дерево? Оказывается, что это еще лучше. И такое де-
рево называют ДЕРЕВОМ ПОИСКА.
     Деревом поиска называется такое дерево, которое построено по
заданной таблице A с выбранным ключом X и в котором значение клю-
ча xi в каждом узле i буде меньше значения ключа xj в каждом пра-
вом поддереве и больше ключа xk в каждом левом.

     Пример.

const N = 100;    { Максимальный размер таблицы с элементами }
                  { типа Person                              }
type NameString = string[10];
     Person = record               { Тип "Персона" характеризует объект }
        Name: NameString;          { по имени (Name), по возрасту (Age),}
        Age,Height,Weight: integer;{по росту (Height) и по весу (Weight)}
     end;
     Index = 1..N;                 {"Основная" таблица PersonsFile      }
     PersonsFile = array[Index] of Person;

     PointerN = ^NameNode;
     NameNode = record
        Name: NameString;    {Тип, определяющий узел дерева        }
        MyIndex: integer;    {поиска по ключу "Имя" (поле Name в   }
        Left,Right: PointerN {таблице MyFile (см. ниже)            }
     end;

     PointerA = ^AgeNode;
     AgeNode = record        {Тип, определяющий узел дерева        }
        Age: integer;        {поиска по ключу "Возраст" (поле Age в}
        MyIndex: integer;    {таблице MyFile (см. ниже)            }
        Left,Right: PointerA
     end;

var Count: Index;
    MyFile: PersonsFile;     { Массив персон }
    NameTree: PointerN;      { Дерево поиска по именам }
    AgeTree: PointerA;       { Дерево поиска по возрасту }

{ Вспомогательная процедура, инициализирующая значения в таблице
  MyFile}
procedure InitFile;
const ExamplNames: array[1..7] of NameString = ('Маша','Саша',
           'Юля','Петя','Коля','Вася','Даша');
      ExamplAges: array[1..7] of integer = (10,5,7,14,8,16,11);
      ExamplHeight: array[1..7] of integer = (15,8,9,48,9,54,32);
      ExamplWeight: array[1..7] of integer = (100,96,98,154,95,168,125);
begin
   for count:= 1 to 7 do
      with MyFile[count] do begin
         Name:= ExamplNames[count];
         Age:= ExamplAges[count];
         Height:= ExamplHeight[count];
         Weight:= ExamplWeight[count]
      end
end;{InitFile}

{Процедура построения  дерева  поиска по ключу "Имя" (Name - в таблице
 MyFile. Элемент с именем N, расположенный в таблице MyFile по индексу
 M помещается в соответствующее место заданного дерева (параметр P)}

procedure BildTreeName(var P: PointerN; N: NameString; M: integer);
begin
   if P=nil then begin
      New(P);
      with P^ do begin
         Name:= N; MyIndex:= M; Left:= nil; Right:= nil
      end
   end
   else
      if P^.Name[1] > N[1] then BildTreeName(P^.Left,N,M)
                           else BildTreeName(P^.Right,N,M)
end;{BildTree}

{Процедура построения дерева поиска по ключу "Возраст" (Age - в табли-
 це MyFile.  Элемент с именем N, расположенный в таблице MyFile по ин-
 дексу M помещается в соответствующее место заданного дерева (параметр
 P)}

procedure BildTreeAge(var P: PointerA; N: integer; M: integer);
begin
   if P=nil then begin
      New(P);
      with P^ do begin
         Age:= N; MyIndex:= M; Left:= nil; Right:= nil
      end
   end
   else
      if P^.Age > N then BildTreeAge(P^.Left,N,M)
                    else BildTreeAge(P^.Right,N,M)
end;{BildTree}

procedure WriteTreeName(P: PointerN);

begin
   if P <> nil then begin
      WriteTreeName(P^.Left);
      WriteLn(MyFile[P^.MyIndex].Name,' ',P^.MyIndex,' ',
                        MyFile[P^.MyIndex].Age);
      WriteTreeName(P^.Right)
   end
end;{WriteTree}

procedure WriteTreeAge(P: PointerA);
begin
   if P <> nil then begin
      WriteTreeAge(P^.Left);
      WriteLn(MyFile[P^.MyIndex].Name,' ',P^.MyIndex,' ',
                        MyFile[P^.MyIndex].Age);
      WriteTreeAge(P^.Right)
   end
end;{WriteTree}

begin
   InitFile; NameTree:= nil; AgeTree:= nil;
   for count:= 1 to 7 do begin
      BildTreeName(NameTree,MyFile[count].Name,count);
      BildTreeAge(AgeTree,MyFile[count].Age,count)
   end;
   WriteTreeName(NameTree); WriteLn;
   WriteTreeAge(AgeTree); ReadLn
end.

2. Содержание задания.
     2.1. Реализовать модуль, позволяющй:
           - построить дерево поиска  для  таблиц  со  структурой,
определяемой типом Person (см. пример), с индексированием по клю-
чам "Имя" и "Возраст";
           - по заданному значению  ключа  найти  соответствующую
запись в таблице и вывести ее на экран;
           - перестраивать дерево поиска при добавлении к таблице
новой записи.
x
     2.2. Реализовать демонстрационный пример, представляющий со-
бой программу, позволяющую:
           - вывести на экран содержимое таблицы, отсортированное
по имени и по возрасту;
           - ввести значение ключа "Имя" или значение ключа "Воз-
раст" и получить значение соответствующей записи.  В  случае  от-
сутствия таковой в таблице - соответствующее сообщение;
           - ввести новую запись в таблицу (с автоматическим  пе-
рестроением деревьев поиска).

   Литература.

1. Н.  Вирт. Алгоритмы + структуры данных = программы. - М.: Мир,
   1985.
