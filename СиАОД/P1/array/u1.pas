{--------------------------------------------------------------------}
{       Модуль для работы со списком (реализация через массив)       }
{--------------------------------------------------------------------}
unit U1;

interface { Интерфейсная часть модуля }

const MaxSize = 10;

type
  LTem = char;  { Тип элемента списка }
  List = record
    Created : boolean; { Список создан, используем свойство компилятора }
                       { заполнять неинициализированные переменные типа Boolean значением false }
    Data : array [1..MaxSize] of LTem; { Элементы списка }
    Cur : 0..MaxSize; { Номер текущего элемента в списке }
    Size : 0..MaxSize; { Количество элементов в списке }
  end;


procedure LtCreate ( var L: List);  {СОЗДАТЬ список}
{ Требования: Нет.
  Результаты: Создан пустой список L. }

procedure LtInsert ( var L: List; NewElem: LTem);  {ВСТАВИТЬ элемент}
{ Требования: Heт.
  Результаты: Новый элемент со значеним NewElemn вставляется в спи-
сок L. Если список L не пуст, новый элемент вставляется вслед  за
текущим; если список пуст, новый элемент становится первым. В лю-
бом случае новый элемент становится текущим элементом списка. }

procedure LtDelete ( var L: List );  {УДАЛИТЬ элемент}
{ Требования: Список L не пуст.
  Результаты: Удаляет текущий элемент из списка L. Если в результа-
те список L не пуст, элемент, который следовал за удаленным  ста-
новится текущим; если удаленный элемент был в конце списка, теку-
щим становится первый элементом списка. }

function LtCurrent ( var L: List) : LTem;   {ТЕКУЩИЙ элемент}
{ Требования: Список L не пуст.
  Результаты: Возвращает значение текущего элемента из списка L. }

procedure LtReplace ( var L: List; NewElem: LTem);  {ЗАМЕНИТЬ элемент}
{ Требования: Список L не пуст.
  Результаты: Заменяет значение текущего элемента из  списка  L  на NewElem. }

procedure LtGoNext ( var L: List );  {ПЕРЕЙТИ на СЛЕДУЮЩИЙ элемент}
{ Требования: Список L не пуст и текущий элемент не последний.
  Результаты: Элемент, непосредственно следующий за текущим, становится текущим элементом списка L. }

procedure LtGoPrior ( var L: List );  {ПЕРЕЙТИ на ПРЕДЫДУЩИЙ элемент}
{ Требования: Список L не пуст и текущий элемент не первый.
  Результаты:  Элемент,  непосредственно  предшествующий  текущему, становится текущим элементом списка L. }

procedure LtGoBegin ( var L: List );  {ПЕРЕЙТИ на ПЕРВЫЙ элемент}
{ Требования: Список L не пуст.
  Результаты: Элемент в начале списка становится текущим  элементом списка L. }

procedure LtGoEnd ( var L: List );  {ПЕРЕЙТИ на ПОСЛЕДНИЙ элемент}
{ Требования: Список L не пуст.
  Результаты: Элемент в конце  списка становится текущим  элементом списка L. }

function LtNotEmpty ( var L: List) : Boolean;   {Список НЕ ПУСТ}
{ Требования: Список L создан.
  Результаты: Возвращает значение TRUE, если список L  не  пуст,  в противном случае возвращает FALSE. }

function LtNotFull ( var L: List) : Boolean;   {Список НЕ ПОЛОН}
{ Требования: Список L создан.
  Результаты: Возвращает значение TRUE, если список L не  полон,  в  противном случае возвращает FALSE. }

function LtAtBegin ( var L: List) : Boolean;   {НАЧАЛО списка}
{ Требования: Список L не пуст.
  Результаты: Возвращает  значение  TRUE,  если  текущим  элементом списка
  L является первый, в противном случае возвращает FALSE. }

function LtAtEnd ( var L: List) : Boolean;      {КОНЕЦ списка}
{ Требования: Список L не пуст.
  Результаты: Возвращает  значение  TRUE,  если  текущим  элементом
списка L является последний, в противном случае возвращает FALSE. }

procedure LtClear ( var L: List );  {ОЧИСТИТЬ список}
{ Требования: Список L создан.
  Результаты: Удалены все элементы списка L. }

procedure LtShow ( var L: List );  {ПОКАЗАТЬ список}
{Замечание. Эта операция формально не входит в СписокАТД и  пред-
назначена только для отладки. В простейшем случае  она  предпола-
гает, что элемент списка можно отобразить непосредственно операто-
ром Write().}
{ Требования: Список L  создан.
  Результаты: Отображает все элементы  списка  L,  если  список  не
пуст, в противном случае выводит сообщение "Список пуст". }

implementation { Реализация функций модуля }

procedure LtCreate ( var L: List);  {СОЗДАТЬ список}
{ Требования: Нет.
  Результаты: Создан пустой список L. }
begin
  L.Size := 0;
  L.Cur := 0;
  L.Created := true;
  assert( L.Created );
end;

procedure LtInsert ( var L: List; NewElem: LTem);  {ВСТАВИТЬ элемент}
{ Требования: Список L не полон.
  Результаты: Новый элемент со значеним NewElemn вставляется в спи-
сок L. Если список L не пуст, новый элемент вставляется вслед  за
текущим; если список пуст, новый элемент становится первым. В лю-
бом случае новый элемент становится текущим элементом списка. }
var i : integer;
begin
  assert( L.Size < MaxSize ); { Список не полон }
  { Сдвигаем все элементы после текущего вправо, чтобы освободить 1 место в массиве }
  for i:=L.Size downto L.Cur+1 do
    L.Data[i+1] := L.Data[i];
  L.Size := L.Size + 1; { Размер при этом увеличится }
  { Записываем новый элемент после текущего }
  L.Data[L.Cur+1] := NewElem;
  { Делаем новый элемент текущим }
  inc( L.Cur );
end;

procedure LtDelete ( var L: List );  {УДАЛИТЬ элемент}
{ Требования: Список L не пуст.
  Результаты: Удаляет текущий элемент из списка L. Если в результа-
те список L не пуст, элемент, который следовал за удаленным  ста-
новится текущим; если удаленный элемент был в конце списка, теку-
щим становится первый элементом списка. }
var i : integer;
begin
  assert( L.Size > 0 );
  { Сдвигаем все элементы влево }
  for i:=L.Cur+1 to L.Size do
    L.Data[i-1] := L.Data[i];
  dec( L.Size );
  if L.Cur > L.Size then
    L.Cur := 1;
end;

function LtCurrent ( var L: List) : LTem;   {ТЕКУЩИЙ элемент}
{ Требования: Список L не пуст.
  Результаты: Возвращает значение текущего элемента из списка L. }
begin
  LtCurrent := L.Data[L.Cur];
end;

procedure LtReplace ( var L: List; NewElem: LTem);  {ЗАМЕНИТЬ элемент}
{ Требования: Список L не пуст.
  Результаты: Заменяет значение текущего элемента из  списка  L  на NewElem. }
begin
  L.Data[L.Cur] := NewElem;
end;

procedure LtGoNext ( var L: List );  {ПЕРЕЙТИ на СЛЕДУЮЩИЙ элемент}
{ Требования: Список L не пуст и текущий элемент не последний.
  Результаты: Элемент, непосредственно следующий за текущим, становится текущим элементом списка L. }
begin
  inc( L.Cur );
end;

procedure LtGoPrior ( var L: List );  {ПЕРЕЙТИ на ПРЕДЫДУЩИЙ элемент}
{ Требования: Список L не пуст и текущий элемент не первый.
  Результаты:  Элемент,  непосредственно  предшествующий  текущему, становится текущим элементом списка L. }
begin
  dec( L.Cur );
end;

procedure LtGoBegin ( var L: List );  {ПЕРЕЙТИ на ПЕРВЫЙ элемент}
{ Требования: Список L не пуст.
  Результаты: Элемент в начале списка становится текущим  элементом списка L. }
begin
  L.Cur := 1;
end;

procedure LtGoEnd ( var L: List );  {ПЕРЕЙТИ на ПОСЛЕДНИЙ элемент}
{ Требования: Список L не пуст.
  Результаты: Элемент в конце  списка становится текущим  элементом списка L. }
begin
  L.Cur := L.Size;
end;

function LtNotEmpty ( var L: List) : Boolean;   {Список НЕ ПУСТ}
{ Требования: Список L создан.
  Результаты: Возвращает значение TRUE, если список L  не  пуст,  в противном случае возвращает FALSE. }
begin
  assert( L.Created );
  LtNotEmpty := L.Size > 0;
end;

function LtNotFull ( var L: List) : Boolean;   {Список НЕ ПОЛОН}
{ Требования: Список L создан.
  Результаты: Возвращает значение TRUE, если список L не  полон,  в  противном случае возвращает FALSE. }
begin
  assert( L.Created );
  LtNotFull := L.Size < MaxSize;
end;

function LtAtBegin ( var L: List) : Boolean;   {НАЧАЛО списка}
{ Требования: Список L не пуст.
  Результаты: Возвращает  значение  TRUE,  если  текущим  элементом списка
  L является первый, в противном случае возвращает FALSE. }
begin
  assert( L.Size > 0 );
  LtAtBegin := L.Cur = 1;
end;

function LtAtEnd ( var L: List) : Boolean;      {КОНЕЦ списка}
{ Требования: Список L не пуст.
  Результаты: Возвращает  значение  TRUE,  если  текущим  элементом
списка L является последний, в противном случае возвращает FALSE. }
begin
  assert( L.Created );
  LtAtEnd := L.Cur = L.Size;
end;

procedure LtClear ( var L: List );  {ОЧИСТИТЬ список}
{ Требования: Список L создан.
  Результаты: Удалены все элементы списка L. }
begin
  assert( L.Created );
  L.Size := 0;
  L.Cur := 0;
end;

procedure LtShow ( var L: List );  {ПОКАЗАТЬ список}
{Замечание. Эта операция формально не входит в СписокАТД и  пред-
назначена только для отладки. В простейшем случае  она  предпола-
гает, что элемент списка можно отобразить непосредственно операто-
ром Write().}
{ Требования: Список L  создан.
  Результаты: Отображает все элементы  списка  L,  если  список  не
пуст, в противном случае выводит сообщение "Список пуст". }
var i : integer;
begin
  assert( L.Created );
  for i:=1 to L.Size do
    writeln('[',i,'] ',L.Data[i]);
  writeln;
end;


end.
